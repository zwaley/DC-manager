# 统一拓扑图系统设计方案

## 文档说明

本文档整合了《端口级拓扑图设计方案》和《拓扑图设计思路与实现方案》两个文档，解决了原有文档间的冲突和重叠问题，提供统一的技术架构和实现指导。

### 文档版本

- 版本：v1.0
- 创建日期：2025-08-27
- 最后更新：2025-08-27
- 状态：设计阶段

## 1. 项目概述

### 1.1 项目背景

动力资源系统需要提供两个层次的拓扑图可视化功能：

1. **设备级拓扑图**：展示设备间的供电关系和电力传输路径
2. **端口级拓扑图**：展示设备端口间的详细连接关系

### 1.2 系统目标

- 提供直观的设备供电关系可视化
- 支持端口级别的精细化连接管理
- 实现智能路径分析和故障影响评估
- 提供统一的用户体验和交互标准
- 确保系统的可扩展性和维护性

### 1.3 功能范围

#### 设备级拓扑图功能

- 设备供电关系可视化
- 电流方向和供电路径展示
- 路径分析和影响评估
- 连接线聚合和智能布局

#### 端口级拓扑图功能

- 端口连接关系详细展示
- 端口状态监控和管理
- 端口搜索和批量操作
- 连接数据导出和分析

## 2. 统一数据模型设计

### 2.1 核心实体定义

#### 2.1.1 设备实体 (Device)

```json
{
  "device_id": "string",           // 设备唯一标识
  "device_name": "string",        // 设备名称
  "asset_number": "string",       // 资产编号
  "device_type": "string",        // 设备类型
  "device_category": "string",    // 设备分类
  "location": "string",           // 设备位置
  "status": "string",             // 设备状态 (online/offline/maintenance)
  "manufacturer": "string",       // 制造商
  "model": "string",              // 型号
  "rated_power": "number",        // 额定功率
  "rated_voltage": "number",      // 额定电压
  "rated_current": "number",      // 额定电流
  "installation_date": "string",  // 安装日期
  "warranty_date": "string",      // 保修期
  "coordinates": {                // 可视化坐标
    "x": "number",
    "y": "number"
  },
  "ports": ["Port"],              // 关联端口列表
  "created_at": "string",         // 创建时间
  "updated_at": "string"          // 更新时间
}
```

#### 2.1.2 端口实体 (Port)

```json
{
  "port_id": "string",            // 端口唯一标识
  "port_name": "string",          // 端口名称
  "port_number": "string",        // 端口编号
  "device_id": "string",          // 所属设备ID
  "port_type": "string",          // 端口类型 (input/output/bidirectional)
  "port_category": "string",      // 端口分类 (power/data/control)
  "connection_status": "string",  // 连接状态 (connected/disconnected/error)
  "port_status": "string",        // 端口状态 (active/inactive/maintenance)
  "rated_voltage": "number",      // 额定电压
  "rated_current": "number",      // 额定电流
  "max_power": "number",          // 最大功率
  "connector_type": "string",     // 连接器类型
  "protocol": "string",           // 通信协议
  "description": "string",        // 端口描述
  "position": {                   // 端口在设备上的位置
    "x": "number",
    "y": "number"
  },
  "created_at": "string",         // 创建时间
  "updated_at": "string"          // 更新时间
}
```

#### 2.1.3 连接实体 (Connection)

```json
{
  "connection_id": "string",      // 连接唯一标识
  "connection_name": "string",    // 连接名称
  "from_device_id": "string",     // 源设备ID
  "from_port_id": "string",       // 源端口ID
  "to_device_id": "string",       // 目标设备ID
  "to_port_id": "string",         // 目标端口ID
  "connection_type": "string",    // 连接类型 (power/data/control)
  "connection_status": "string",  // 连接状态 (active/inactive/error)
  "hierarchy_relation": "string", // 层级关系 (parent/child/peer)
  "upstream_downstream": "string", // 上下游关系 (upstream/downstream)
  "power_direction": "string",    // 电流方向 (forward/reverse/bidirectional)
  "rated_current": "number",      // 额定电流
  "actual_current": "number",     // 实际电流
  "cable_type": "string",         // 线缆类型
  "cable_length": "number",       // 线缆长度
  "parallel_count": "number",     // 并联数量
  "installation_date": "string",  // 安装日期
  "maintenance_date": "string",   // 维护日期
  "description": "string",        // 连接描述
  "created_at": "string",         // 创建时间
  "updated_at": "string"          // 更新时间
}
```

### 2.2 详细数据库设计

#### 2.2.1 数据库表结构定义

**设备表 (devices)**

```sql
CREATE TABLE devices (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    asset_id VARCHAR(50) UNIQUE NOT NULL,           -- 资产编号
    name VARCHAR(100) NOT NULL,                     -- 设备名称
    station VARCHAR(100) NOT NULL,                  -- 局站
    model VARCHAR(100),                             -- 设备型号
    device_type VARCHAR(50),                        -- 设备类型
    location VARCHAR(200),                          -- 机房内空间位置
    power_rating VARCHAR(50),                       -- 设备额定容量
    vendor VARCHAR(100),                            -- 设备生产厂家
    commission_date VARCHAR(20),                    -- 设备投产时间
    remark TEXT,                                    -- 备注

    -- 机房相关字段
    room_name VARCHAR(100),                         -- 机房名称
    resource_room_name VARCHAR(100),                -- 资源系统机房名称
    resource_room_code VARCHAR(50),                 -- 资源系统机房编码
    room_level VARCHAR(20),                         -- 机房等级
    system_name VARCHAR(100),                       -- 所属系统

    -- 拓扑图可视化字段
    topology_x FLOAT DEFAULT 0,                    -- 拓扑图X坐标
    topology_y FLOAT DEFAULT 0,                    -- 拓扑图Y坐标
    topology_layer INTEGER DEFAULT 0,              -- 拓扑图层级
    node_style VARCHAR(50) DEFAULT 'default',      -- 节点样式
    is_critical BOOLEAN DEFAULT FALSE,             -- 是否关键设备
    display_priority INTEGER DEFAULT 0,            -- 显示优先级

    -- 索引
    INDEX idx_asset_id (asset_id),
    INDEX idx_name (name),
    INDEX idx_station (station),
    INDEX idx_device_type (device_type),
    INDEX idx_room_name (room_name),
    INDEX idx_resource_room_code (resource_room_code),
    INDEX idx_system_name (system_name),
    INDEX idx_topology_layer (topology_layer)
);
```

**连接表 (connections)**

```sql
CREATE TABLE connections (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    source_device_id INTEGER NOT NULL,
    target_device_id INTEGER NOT NULL,

    -- A端（源端）信息
    source_port VARCHAR(100),                       -- A端端口
    source_fuse_number VARCHAR(50),                 -- A端熔丝编号
    source_fuse_spec VARCHAR(100),                  -- A端熔丝规格
    source_breaker_number VARCHAR(50),              -- A端空开编号
    source_breaker_spec VARCHAR(100),               -- A端空开规格

    -- B端（目标端）信息
    target_port VARCHAR(100),                       -- B端端口
    target_fuse_number VARCHAR(50),                 -- B端熔丝编号
    target_fuse_spec VARCHAR(100),                  -- B端熔丝规格
    target_breaker_number VARCHAR(50),              -- B端空开编号
    target_breaker_spec VARCHAR(100),               -- B端空开规格
    target_device_location VARCHAR(200),            -- B端设备位置

    -- 连接信息
    hierarchy_relation VARCHAR(20),                 -- 上下级关系
    upstream_downstream VARCHAR(20),                -- 上下游关系
    connection_type VARCHAR(20),                    -- 连接类型
    cable_model VARCHAR(100),                       -- 电缆型号
    cable_type VARCHAR(100),                        -- 电缆类型
    cable_specification VARCHAR(100),               -- 电缆规格
    parallel_count INTEGER DEFAULT 1,              -- 并联数量
    rated_current FLOAT,                            -- 额定电流
    cable_length FLOAT,                             -- 电缆长度

    -- 附加信息
    source_device_photo VARCHAR(500),               -- A端设备照片
    target_device_photo VARCHAR(500),               -- B端设备照片
    remark TEXT,                                    -- 备注
    installation_date DATE,                        -- 安装日期
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,

    -- 外键约束
    FOREIGN KEY (source_device_id) REFERENCES devices(id),
    FOREIGN KEY (target_device_id) REFERENCES devices(id),

    -- 索引
    INDEX idx_source_device (source_device_id),
    INDEX idx_target_device (target_device_id),
    INDEX idx_connection_type (connection_type),
    INDEX idx_hierarchy_relation (hierarchy_relation)
);
```

**生命周期规则表 (lifecycle_rules)**

```sql
CREATE TABLE lifecycle_rules (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    device_type VARCHAR(50) UNIQUE NOT NULL,       -- 设备类型
    lifecycle_years INTEGER NOT NULL,              -- 生命周期年限
    warning_months INTEGER DEFAULT 6,              -- 提前提醒月数
    description TEXT,                               -- 规则描述
    is_active VARCHAR(10) DEFAULT 'true',          -- 是否启用
    created_at VARCHAR(30),                        -- 创建时间
    updated_at VARCHAR(30),                        -- 更新时间

    INDEX idx_device_type (device_type),
    INDEX idx_is_active (is_active)
);
```

#### 2.2.2 数据关系设计

**实体关系图**

```
Device (1) -----> (N) Connection (source_device)
Device (1) -----> (N) Connection (target_device)
Device (N) -----> (1) LifecycleRule (device_type)
```

**关系约束**

1. **设备表约束**
   
   - asset_id 必须唯一且不能为空
   - name, station 不能为空
   - device_type 关联生命周期规则
   - 拓扑坐标默认为(0,0)

2. **连接表约束**
   
   - source_device_id 和 target_device_id 必须存在
   - 不能连接同一个设备（source_device_id ≠ target_device_id）
   - connection_type 只能是 'cable', 'busbar', 'busway' 或 NULL
   - hierarchy_relation 只能是预定义值

3. **生命周期规则约束**
   
   - device_type 必须唯一
   - lifecycle_years 必须大于0
   - warning_months 必须在1-36之间

#### 2.2.3 索引设计和性能优化

**主要索引策略**

1. **设备表索引**
   
   - 主键索引：id (自动创建)
   - 唯一索引：asset_id
   - 复合索引：(station, device_type) - 用于按局站和类型查询
   - 复合索引：(room_name, system_name) - 用于机房系统查询
   - 空间索引：(topology_x, topology_y) - 用于拓扑图范围查询

2. **连接表索引**
   
   - 主键索引：id (自动创建)
   - 外键索引：source_device_id, target_device_id
   - 复合索引：(source_device_id, target_device_id) - 用于路径查询
   - 复合索引：(connection_type, hierarchy_relation) - 用于拓扑分析

**查询优化建议**

```sql
-- 高效的拓扑查询
SELECT d1.name as source_name, d2.name as target_name, 
       c.hierarchy_relation, c.connection_type
FROM connections c
JOIN devices d1 ON c.source_device_id = d1.id
JOIN devices d2 ON c.target_device_id = d2.id
WHERE d1.station = ? AND c.connection_type IS NOT NULL;

-- 设备层级查询
WITH RECURSIVE device_hierarchy AS (
    SELECT id, name, 0 as level
    FROM devices 
    WHERE id = ?

    UNION ALL

    SELECT d.id, d.name, dh.level + 1
    FROM devices d
    JOIN connections c ON d.id = c.target_device_id
    JOIN device_hierarchy dh ON c.source_device_id = dh.id
    WHERE dh.level < 10
)
SELECT * FROM device_hierarchy;
```

#### 2.2.4 数据迁移和初始化脚本

**数据迁移脚本 (migrate_topology_fields.py)**

```python
#!/usr/bin/env python3
"""
拓扑图字段迁移脚本
为现有设备表添加拓扑图可视化相关字段
"""

import sqlite3
import os
from datetime import datetime

def migrate_topology_fields():
    """为设备表添加拓扑图相关字段"""
    db_path = "data/devices.db"

    if not os.path.exists(db_path):
        print(f"数据库文件不存在: {db_path}")
        return False

    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()

        # 检查是否已经存在拓扑字段
        cursor.execute("PRAGMA table_info(devices)")
        columns = [column[1] for column in cursor.fetchall()]

        topology_fields = [
            ('topology_x', 'REAL DEFAULT 0'),
            ('topology_y', 'REAL DEFAULT 0'),
            ('topology_layer', 'INTEGER DEFAULT 0'),
            ('node_style', 'VARCHAR(50) DEFAULT "default"'),
            ('is_critical', 'BOOLEAN DEFAULT 0'),
            ('display_priority', 'INTEGER DEFAULT 0')
        ]

        for field_name, field_def in topology_fields:
            if field_name not in columns:
                sql = f"ALTER TABLE devices ADD COLUMN {field_name} {field_def}"
                cursor.execute(sql)
                print(f"添加字段: {field_name}")
            else:
                print(f"字段已存在: {field_name}")

        # 创建拓扑相关索引
        indexes = [
            "CREATE INDEX IF NOT EXISTS idx_topology_layer ON devices(topology_layer)",
            "CREATE INDEX IF NOT EXISTS idx_is_critical ON devices(is_critical)",
            "CREATE INDEX IF NOT EXISTS idx_display_priority ON devices(display_priority)"
        ]

        for index_sql in indexes:
            cursor.execute(index_sql)
            print(f"创建索引: {index_sql.split('ON')[0].split('IF NOT EXISTS')[1].strip()}")

        conn.commit()
        print("拓扑字段迁移完成")
        return True

    except Exception as e:
        print(f"迁移失败: {e}")
        return False
    finally:
        conn.close()

if __name__ == "__main__":
    migrate_topology_fields()
```

**初始化数据脚本 (init_topology_data.py)**

```python
#!/usr/bin/env python3
"""
拓扑图初始化数据脚本
为现有设备设置默认的拓扑图属性
"""

import sqlite3
import random
import math

def init_topology_positions():
    """为现有设备初始化拓扑图位置"""
    db_path = "data/devices.db"

    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()

        # 获取所有设备
        cursor.execute("""
            SELECT id, name, device_type, station 
            FROM devices 
            WHERE topology_x = 0 AND topology_y = 0
        """)
        devices = cursor.fetchall()

        if not devices:
            print("没有需要初始化位置的设备")
            return

        # 按局站分组布局
        stations = {}
        for device in devices:
            station = device[3] or "未知局站"
            if station not in stations:
                stations[station] = []
            stations[station].append(device)

        # 为每个局站分配区域
        station_positions = {}
        station_count = len(stations)
        cols = math.ceil(math.sqrt(station_count))

        for i, station in enumerate(stations.keys()):
            row = i // cols
            col = i % cols
            station_positions[station] = {
                'base_x': col * 800 + 100,
                'base_y': row * 600 + 100
            }

        # 为每个设备分配位置
        updates = []
        for station, devices_in_station in stations.items():
            base_pos = station_positions[station]
            device_count = len(devices_in_station)

            for j, device in enumerate(devices_in_station):
                # 在局站区域内随机分布
                x = base_pos['base_x'] + (j % 10) * 70 + random.randint(-20, 20)
                y = base_pos['base_y'] + (j // 10) * 80 + random.randint(-20, 20)

                # 根据设备类型设置层级和样式
                device_type = device[2] or "unknown"
                layer = get_device_layer(device_type)
                style = get_device_style(device_type)
                is_critical = is_critical_device(device_type)

                updates.append((
                    x, y, layer, style, is_critical, device[0]
                ))

        # 批量更新
        cursor.executemany("""
            UPDATE devices 
            SET topology_x = ?, topology_y = ?, topology_layer = ?, 
                node_style = ?, is_critical = ?
            WHERE id = ?
        """, updates)

        conn.commit()
        print(f"已为 {len(updates)} 个设备初始化拓扑位置")

    except Exception as e:
        print(f"初始化失败: {e}")
    finally:
        conn.close()

def get_device_layer(device_type):
    """根据设备类型确定拓扑层级"""
    layer_map = {
        '高压配电': 1,
        '变压器': 2,
        '低压配电': 3,
        'UPS': 4,
        '蓄电池': 4,
        '整流器': 4,
        '开关电源': 5,
        '服务器': 6,
        '网络设备': 6
    }
    return layer_map.get(device_type, 0)

def get_device_style(device_type):
    """根据设备类型确定节点样式"""
    style_map = {
        '高压配电': 'power_high',
        '变压器': 'transformer',
        '低压配电': 'power_low',
        'UPS': 'ups',
        '蓄电池': 'battery',
        '整流器': 'rectifier',
        '开关电源': 'switch_power',
        '服务器': 'server',
        '网络设备': 'network'
    }
    return style_map.get(device_type, 'default')

def is_critical_device(device_type):
    """判断是否为关键设备"""
    critical_types = ['高压配电', '变压器', 'UPS', '核心交换机']
    return device_type in critical_types

if __name__ == "__main__":
    init_topology_positions()
```

### 2.3 数据兼容性处理

#### 2.3.1 字段映射规则

**原端口级文档字段映射：**

```
device_id -> device_id
device_name -> device_name
device_type -> device_type
ports -> ports
```

**原拓扑图文档字段映射：**

```
id -> device_id
device_name -> device_name
asset_number -> asset_number
device_a -> from_device_id
device_b -> to_device_id
hierarchy_relation -> hierarchy_relation
upstream_downstream -> upstream_downstream
```

#### 2.3.2 数据迁移策略

1. **向后兼容**：保留原有字段作为别名
2. **渐进迁移**：分阶段更新数据结构
3. **数据验证**：确保迁移后数据完整性

## 3. 核心算法实现

### 3.1 拓扑构建算法

#### 3.1.1 设备级拓扑构建 (build_device_topology)

```python
def build_device_topology(location_filter=None, device_type_filter=None, include_offline=True):
    """
    构建设备级拓扑图数据

    Args:
        location_filter: 位置筛选条件
        device_type_filter: 设备类型筛选条件
        include_offline: 是否包含离线设备

    Returns:
        dict: 包含nodes和edges的拓扑数据
    """
    from models import Device, Connection
    from sqlalchemy.orm import sessionmaker

    session = SessionLocal()
    try:
        # 构建设备查询
        device_query = session.query(Device)

        if location_filter:
            device_query = device_query.filter(Device.station.like(f"%{location_filter}%"))

        if device_type_filter:
            device_query = device_query.filter(Device.device_type == device_type_filter)

        if not include_offline:
            # 假设有status字段，这里需要根据实际情况调整
            pass

        devices = device_query.all()
        device_ids = [d.id for d in devices]

        # 获取设备间的连接关系
        connections = session.query(Connection).filter(
            Connection.source_device_id.in_(device_ids),
            Connection.target_device_id.in_(device_ids),
            Connection.connection_type.isnot(None)  # 排除空闲端口
        ).all()

        # 构建节点数据
        nodes = []
        for device in devices:
            node = {
                "id": f"device_{device.id}",
                "label": device.name,
                "type": device.device_type or "unknown",
                "station": device.station,
                "position": {
                    "x": device.topology_x or 0,
                    "y": device.topology_y or 0
                },
                "layer": device.topology_layer or 0,
                "style": device.node_style or "default",
                "is_critical": bool(device.is_critical),
                "properties": {
                    "asset_id": device.asset_id,
                    "model": device.model,
                    "location": device.location,
                    "power_rating": device.power_rating,
                    "vendor": device.vendor,
                    "room_name": device.room_name,
                    "system_name": device.system_name
                }
            }
            nodes.append(node)

        # 构建边数据
        edges = []
        for conn in connections:
            edge = {
                "id": f"conn_{conn.id}",
                "from": f"device_{conn.source_device_id}",
                "to": f"device_{conn.target_device_id}",
                "type": conn.connection_type,
                "hierarchy": conn.hierarchy_relation,
                "direction": get_power_direction(conn),
                "properties": {
                    "cable_model": conn.cable_model,
                    "cable_specification": conn.cable_specification,
                    "rated_current": conn.rated_current,
                    "parallel_count": conn.parallel_count,
                    "cable_length": conn.cable_length
                }
            }
            edges.append(edge)

        return {
            "nodes": nodes,
            "edges": edges,
            "layout": {
                "algorithm": "hierarchical",
                "direction": "UD"
            }
        }

    finally:
        session.close()

def get_power_direction(connection):
    """根据连接关系确定电流方向"""
    if connection.hierarchy_relation:
        if "上" in connection.hierarchy_relation:
            return "forward"  # 从上级到下级
        elif "下" in connection.hierarchy_relation:
            return "reverse"  # 从下级到上级

    if connection.upstream_downstream:
        if connection.upstream_downstream == "上游":
            return "forward"
        elif connection.upstream_downstream == "下游":
            return "reverse"

    return "bidirectional"  # 双向或未知
```

#### 3.1.2 端口级拓扑构建 (build_port_topology)

```python
def build_port_topology(device_ids=None, port_types=None, connection_status=None):
    """
    构建端口级拓扑图数据

    Args:
        device_ids: 设备ID列表
        port_types: 端口类型筛选
        connection_status: 连接状态筛选

    Returns:
        dict: 包含devices和connections的端口级拓扑数据
    """
    from models import Device, Connection

    session = SessionLocal()
    try:
        # 获取设备信息
        device_query = session.query(Device)
        if device_ids:
            device_query = device_query.filter(Device.id.in_(device_ids))

        devices = device_query.all()
        device_id_list = [d.id for d in devices]

        # 获取连接信息
        conn_query = session.query(Connection).filter(
            Connection.source_device_id.in_(device_id_list),
            Connection.target_device_id.in_(device_id_list)
        )

        if connection_status == "connected":
            conn_query = conn_query.filter(Connection.connection_type.isnot(None))
        elif connection_status == "disconnected":
            conn_query = conn_query.filter(Connection.connection_type.is_(None))

        connections = conn_query.all()

        # 构建端口级数据结构
        result_devices = []
        for device in devices:
            # 获取设备的所有端口（从连接表推导）
            device_ports = extract_device_ports(device, connections)

            device_data = {
                "device_id": f"device_{device.id}",
                "device_name": device.name,
                "device_type": device.device_type,
                "position": {
                    "x": device.topology_x or 0,
                    "y": device.topology_y or 0
                },
                "ports": device_ports
            }
            result_devices.append(device_data)

        # 构建连接数据
        result_connections = []
        for conn in connections:
            if conn.connection_type:  # 只包含实际连接
                conn_data = {
                    "connection_id": f"conn_{conn.id}",
                    "from_device": f"device_{conn.source_device_id}",
                    "to_device": f"device_{conn.target_device_id}",
                    "from_port": conn.source_port or "unknown",
                    "to_port": conn.target_port or "unknown",
                    "connection_type": conn.connection_type,
                    "status": "active",  # 根据实际情况调整
                    "properties": {
                        "cable_model": conn.cable_model,
                        "rated_current": conn.rated_current,
                        "cable_length": conn.cable_length
                    }
                }
                result_connections.append(conn_data)

        return {
            "devices": result_devices,
            "connections": result_connections
        }

    finally:
        session.close()

def extract_device_ports(device, connections):
    """从连接数据中提取设备端口信息"""
    ports = set()

    # 从作为源设备的连接中提取端口
    for conn in connections:
        if conn.source_device_id == device.id and conn.source_port:
            ports.add((conn.source_port, "output"))
        if conn.target_device_id == device.id and conn.target_port:
            ports.add((conn.target_port, "input"))

    # 构建端口数据
    port_list = []
    for i, (port_name, port_type) in enumerate(sorted(ports)):
        port_data = {
            "port_id": f"port_{device.id}_{i}",
            "port_name": port_name,
            "port_type": port_type,
            "status": "connected",  # 根据实际连接状态确定
            "position": {
                "x": (i % 4) * 30,  # 简单的端口布局
                "y": (i // 4) * 20
            }
        }
        port_list.append(port_data)

    return port_list
```

### 3.2 路径分析算法

#### 3.2.1 最短路径分析 (find_shortest_path)

```python
import heapq
from collections import defaultdict, deque

def find_shortest_path(source_device_id, target_device_id, max_paths=5):
    """
    查找设备间的最短路径

    Args:
        source_device_id: 源设备ID
        target_device_id: 目标设备ID
        max_paths: 最大路径数量

    Returns:
        list: 路径列表，按优先级排序
    """
    from models import Device, Connection

    session = SessionLocal()
    try:
        # 构建图结构
        graph = build_device_graph(session)

        # 使用Dijkstra算法查找最短路径
        paths = dijkstra_all_paths(
            graph, source_device_id, target_device_id, max_paths
        )

        # 计算路径属性
        result_paths = []
        for i, path in enumerate(paths):
            path_data = {
                "path_id": f"path_{i+1}",
                "devices": path,
                "connections": get_path_connections(session, path),
                "total_length": len(path) - 1,
                "reliability_score": calculate_path_reliability(session, path),
                "power_capacity": calculate_path_capacity(session, path),
                "total_distance": calculate_path_distance(session, path)
            }
            result_paths.append(path_data)

        return {
            "paths": result_paths,
            "analysis_summary": {
                "total_paths": len(result_paths),
                "recommended_path": result_paths[0]["path_id"] if result_paths else None,
                "risk_assessment": assess_path_risk(result_paths)
            }
        }

    finally:
        session.close()

def build_device_graph(session):
    """构建设备连接图"""
    connections = session.query(Connection).filter(
        Connection.connection_type.isnot(None)
    ).all()

    graph = defaultdict(list)
    for conn in connections:
        # 构建双向图（根据实际需求可能需要调整）
        weight = calculate_edge_weight(conn)
        graph[conn.source_device_id].append({
            "target": conn.target_device_id,
            "weight": weight,
            "connection": conn
        })
        graph[conn.target_device_id].append({
            "target": conn.source_device_id,
            "weight": weight,
            "connection": conn
        })

    return graph

def calculate_edge_weight(connection):
    """计算连接边的权重"""
    weight = 1.0  # 基础权重

    # 根据电缆长度调整权重
    if connection.cable_length:
        weight += connection.cable_length * 0.01

    # 根据连接类型调整权重
    type_weights = {
        "cable": 1.0,
        "busbar": 0.5,
        "busway": 0.3
    }
    weight *= type_weights.get(connection.connection_type, 1.0)

    # 根据额定电流调整权重（电流越大，权重越小）
    if connection.rated_current and connection.rated_current > 0:
        weight *= (100.0 / connection.rated_current)

    return weight

def dijkstra_all_paths(graph, start, end, max_paths):
    """使用Dijkstra算法查找多条最短路径"""
    # 优先队列：(距离, 路径)
    pq = [(0, [start])]
    visited_paths = set()
    result_paths = []

    while pq and len(result_paths) < max_paths:
        current_dist, path = heapq.heappop(pq)
        current_node = path[-1]

        # 到达目标节点
        if current_node == end:
            path_key = tuple(path)
            if path_key not in visited_paths:
                visited_paths.add(path_key)
                result_paths.append(path)
            continue

        # 避免环路
        if len(path) > 10:  # 最大路径长度限制
            continue

        # 扩展路径
        for neighbor in graph.get(current_node, []):
            next_node = neighbor["target"]
            if next_node not in path:  # 避免环路
                new_dist = current_dist + neighbor["weight"]
                new_path = path + [next_node]
                heapq.heappush(pq, (new_dist, new_path))

    return result_paths

def calculate_path_reliability(session, path):
    """计算路径可靠性"""
    if len(path) < 2:
        return 1.0

    reliability = 1.0
    for i in range(len(path) - 1):
        # 获取连接信息
        conn = session.query(Connection).filter(
            ((Connection.source_device_id == path[i]) & 
             (Connection.target_device_id == path[i+1])) |
            ((Connection.source_device_id == path[i+1]) & 
             (Connection.target_device_id == path[i]))
        ).first()

        if conn:
            # 根据连接类型和状态计算可靠性
            conn_reliability = get_connection_reliability(conn)
            reliability *= conn_reliability

    return round(reliability, 3)

def get_connection_reliability(connection):
    """获取连接的可靠性系数"""
    base_reliability = {
        "cable": 0.95,
        "busbar": 0.98,
        "busway": 0.97
    }

    reliability = base_reliability.get(connection.connection_type, 0.90)

    # 根据电缆长度调整（长度越长，可靠性越低）
    if connection.cable_length and connection.cable_length > 100:
        reliability *= (1 - (connection.cable_length - 100) * 0.001)

    return max(reliability, 0.5)  # 最低可靠性限制

def calculate_path_capacity(session, path):
    """计算路径的功率容量（瓶颈容量）"""
    if len(path) < 2:
        return float('inf')

    min_capacity = float('inf')
    for i in range(len(path) - 1):
        conn = session.query(Connection).filter(
            ((Connection.source_device_id == path[i]) & 
             (Connection.target_device_id == path[i+1])) |
            ((Connection.source_device_id == path[i+1]) & 
             (Connection.target_device_id == path[i]))
        ).first()

        if conn and conn.rated_current:
            # 考虑并联数量
            capacity = conn.rated_current * (conn.parallel_count or 1)
            min_capacity = min(min_capacity, capacity)

    return min_capacity if min_capacity != float('inf') else 0
```

### 3.3 故障影响分析算法

#### 3.3.1 故障影响分析 (analyze_failure_impact)

```python
def analyze_failure_impact(failed_device_id, failure_type="complete", analysis_scope="extended"):
    """
    分析设备故障的影响范围

    Args:
        failed_device_id: 故障设备ID
        failure_type: 故障类型 (complete/partial/maintenance)
        analysis_scope: 分析范围 (immediate/extended/full)

    Returns:
        dict: 故障影响分析结果
    """
    from models import Device, Connection

    session = SessionLocal()
    try:
        # 获取故障设备信息
        failed_device = session.query(Device).filter(Device.id == failed_device_id).first()
        if not failed_device:
            return {"error": "设备不存在"}

        # 构建设备图
        graph = build_device_graph(session)

        # 查找受影响的设备
        affected_devices = find_affected_nodes(
            graph, failed_device_id, failure_type, analysis_scope
        )

        # 分析影响程度
        impact_analysis = []
        critical_count = 0

        for device_id in affected_devices:
            device = session.query(Device).filter(Device.id == device_id).first()
            if device:
                impact_type, criticality = assess_device_impact(
                    session, device, failed_device_id, failure_type
                )

                alternative_paths = count_alternative_paths(
                    graph, device_id, failed_device_id
                )

                impact_data = {
                    "device_id": f"device_{device.id}",
                    "device_name": device.name,
                    "impact_type": impact_type,
                    "criticality": criticality,
                    "alternative_paths": alternative_paths,
                    "estimated_downtime": estimate_downtime(device, failure_type)
                }

                impact_analysis.append(impact_data)
                if criticality == "high":
                    critical_count += 1

        # 生成建议
        recommendations = generate_failure_recommendations(
            session, failed_device, affected_devices, failure_type
        )

        # 计算总体风险等级
        risk_level = calculate_overall_risk(len(affected_devices), critical_count)

        return {
            "impact_summary": {
                "affected_devices": len(affected_devices),
                "critical_devices": critical_count,
                "estimated_downtime": estimate_total_downtime(impact_analysis),
                "risk_level": risk_level
            },
            "affected_devices": impact_analysis,
            "recommendations": recommendations
        }

    finally:
        session.close()

def find_affected_nodes(graph, failed_device_id, failure_type, analysis_scope):
    """查找受故障影响的设备节点"""
    affected = set()

    if failure_type == "complete":
        # 完全故障：查找所有下游设备
        affected = find_downstream_devices(graph, failed_device_id, analysis_scope)
    elif failure_type == "partial":
        # 部分故障：查找直接连接的设备
        affected = find_directly_connected_devices(graph, failed_device_id)
    elif failure_type == "maintenance":
        # 维护模式：查找可能受影响的关键设备
        affected = find_critical_dependent_devices(graph, failed_device_id)

    return affected

def find_downstream_devices(graph, start_device_id, scope):
    """查找下游设备"""
    visited = set()
    queue = deque([start_device_id])
    max_depth = {"immediate": 1, "extended": 3, "full": 10}.get(scope, 3)

    # BFS遍历下游设备
    current_depth = 0
    while queue and current_depth < max_depth:
        level_size = len(queue)
        current_depth += 1

        for _ in range(level_size):
            current_device = queue.popleft()
            if current_device in visited:
                continue

            visited.add(current_device)

            # 查找下游连接（根据hierarchy_relation判断）
            for neighbor in graph.get(current_device, []):
                conn = neighbor["connection"]
                target_device = neighbor["target"]

                # 判断是否为下游连接
                if is_downstream_connection(conn, current_device):
                    if target_device not in visited:
                        queue.append(target_device)

    visited.discard(start_device_id)  # 移除起始设备
    return visited

def is_downstream_connection(connection, current_device_id):
    """判断是否为下游连接"""
    if connection.hierarchy_relation:
        # 如果当前设备是源设备且关系为"上级"，则目标设备为下游
        if (connection.source_device_id == current_device_id and 
            "上" in connection.hierarchy_relation):
            return True
        # 如果当前设备是目标设备且关系为"下级"，则源设备为上游
        if (connection.target_device_id == current_device_id and 
            "下" in connection.hierarchy_relation):
            return False

    # 根据upstream_downstream字段判断
    if connection.upstream_downstream:
        if (connection.source_device_id == current_device_id and 
            connection.upstream_downstream == "上游"):
            return True

    return False

def assess_device_impact(session, device, failed_device_id, failure_type):
    """评估设备受影响程度"""
    impact_type = "power_loss"  # 默认为电力损失

    # 根据设备类型确定影响类型
    if device.device_type in ["服务器", "网络设备"]:
        impact_type = "service_interruption"
    elif device.device_type in ["UPS", "蓄电池"]:
        impact_type = "backup_activation"

    # 评估关键程度
    criticality = "low"
    if device.is_critical:
        criticality = "high"
    elif device.device_type in ["UPS", "变压器", "高压配电"]:
        criticality = "medium"

    return impact_type, criticality

def estimate_downtime(device, failure_type):
    """估算设备停机时间"""
    base_downtime = {
        "complete": "4h",
        "partial": "2h", 
        "maintenance": "1h"
    }

    downtime = base_downtime.get(failure_type, "2h")

    # 根据设备类型调整
    if device.device_type in ["高压配电", "变压器"]:
        # 高压设备修复时间更长
        multiplier = {"complete": 2, "partial": 1.5, "maintenance": 1}.get(failure_type, 1)
        hours = int(downtime.replace("h", "")) * multiplier
        downtime = f"{hours}h"

    return downtime

def generate_failure_recommendations(session, failed_device, affected_devices, failure_type):
    """生成故障处理建议"""
    recommendations = []

    # 基础建议
    if failure_type == "complete":
        recommendations.append({
            "action": "isolate_failed_device",
            "priority": "immediate",
            "description": f"立即隔离故障设备：{failed_device.name}"
        })

        recommendations.append({
            "action": "activate_backup_power",
            "priority": "immediate", 
            "description": "启动备用电源系统"
        })

    # 根据受影响设备数量生成建议
    if len(affected_devices) > 10:
        recommendations.append({
            "action": "emergency_response",
            "priority": "immediate",
            "description": "启动应急响应预案，影响范围较大"
        })

    # 检查是否有备用路径
    graph = build_device_graph(session)
    for device_id in affected_devices:
        alt_paths = count_alternative_paths(graph, device_id, failed_device.id)
        if alt_paths > 0:
            recommendations.append({
                "action": "switch_to_alternative_path",
                "priority": "high",
                "description": f"为受影响设备切换到备用供电路径"
            })
            break

    return recommendations
```

## 4. 统一API接口规范

### 4.1 API架构设计

#### 4.1.1 RESTful API设计原则

```python
# API基础配置
API_BASE_URL = "/api/v1/topology"
API_VERSION = "1.0"

# 通用响应格式
class APIResponse:
    def __init__(self, success=True, data=None, message="", error_code=None):
        self.success = success
        self.data = data
        self.message = message
        self.error_code = error_code
        self.timestamp = datetime.now().isoformat()

    def to_dict(self):
        return {
            "success": self.success,
            "data": self.data,
            "message": self.message,
            "error_code": self.error_code,
            "timestamp": self.timestamp
        }

# 错误代码定义
ERROR_CODES = {
    "DEVICE_NOT_FOUND": 1001,
    "INVALID_PARAMETERS": 1002,
    "DATABASE_ERROR": 1003,
    "TOPOLOGY_BUILD_FAILED": 1004,
    "PATH_NOT_FOUND": 1005,
    "ANALYSIS_FAILED": 1006,
    "PERMISSION_DENIED": 1007,
    "RATE_LIMIT_EXCEEDED": 1008
}
```

#### 4.1.2 认证和权限控制

```python
from functools import wraps
from flask_jwt_extended import verify_jwt_in_request, get_jwt_identity

def require_auth(f):
    """API认证装饰器"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        try:
            verify_jwt_in_request()
            return f(*args, **kwargs)
        except Exception as e:
            return APIResponse(
                success=False,
                message="认证失败",
                error_code=ERROR_CODES["PERMISSION_DENIED"]
            ).to_dict(), 401
    return decorated_function

def require_permission(permission):
    """权限检查装饰器"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            user_id = get_jwt_identity()
            if not check_user_permission(user_id, permission):
                return APIResponse(
                    success=False,
                    message="权限不足",
                    error_code=ERROR_CODES["PERMISSION_DENIED"]
                ).to_dict(), 403
            return f(*args, **kwargs)
        return decorated_function
    return decorator
```

### 4.2 设备级拓扑图API

#### 4.2.1 获取设备拓扑数据

**接口定义**

```
GET /api/v1/topology/devices
```

**请求参数**

```python
# Query Parameters
class DeviceTopologyRequest:
    location_filter: Optional[str] = None      # 位置筛选
    device_type_filter: Optional[str] = None   # 设备类型筛选
    include_offline: bool = True               # 是否包含离线设备
    layout_algorithm: str = "hierarchical"     # 布局算法
    max_nodes: int = 1000                      # 最大节点数
    include_properties: bool = True            # 是否包含详细属性
```

**完整API实现**

```python
from flask import Blueprint, request, jsonify
from marshmallow import Schema, fields, ValidationError

topology_bp = Blueprint('topology', __name__, url_prefix='/api/v1/topology')

class DeviceTopologyRequestSchema(Schema):
    location_filter = fields.Str(missing=None)
    device_type_filter = fields.Str(missing=None)
    include_offline = fields.Bool(missing=True)
    layout_algorithm = fields.Str(missing="hierarchical")
    max_nodes = fields.Int(missing=1000, validate=lambda x: 1 <= x <= 5000)
    include_properties = fields.Bool(missing=True)

@topology_bp.route('/devices', methods=['GET'])
@require_auth
@require_permission('topology:read')
def get_device_topology():
    """获取设备级拓扑图数据"""
    schema = DeviceTopologyRequestSchema()

    try:
        # 参数验证
        params = schema.load(request.args)

        # 构建拓扑数据
        topology_data = build_device_topology(
            location_filter=params['location_filter'],
            device_type_filter=params['device_type_filter'],
            include_offline=params['include_offline']
        )

        # 节点数量限制
        if len(topology_data['nodes']) > params['max_nodes']:
            return APIResponse(
                success=False,
                message=f"节点数量超过限制({params['max_nodes']})，请使用筛选条件",
                error_code=ERROR_CODES["INVALID_PARAMETERS"]
            ).to_dict(), 400

        # 简化属性（如果不需要详细属性）
        if not params['include_properties']:
            for node in topology_data['nodes']:
                node.pop('properties', None)

        # 添加元数据
        response_data = {
            "topology": topology_data,
            "metadata": {
                "total_nodes": len(topology_data['nodes']),
                "total_edges": len(topology_data['edges']),
                "layout_algorithm": params['layout_algorithm'],
                "generated_at": datetime.now().isoformat()
            }
        }

        return APIResponse(
            success=True,
            data=response_data,
            message="拓扑数据获取成功"
        ).to_dict()

    except ValidationError as e:
        return APIResponse(
            success=False,
            message="参数验证失败",
            error_code=ERROR_CODES["INVALID_PARAMETERS"],
            data={"validation_errors": e.messages}
        ).to_dict(), 400

    except Exception as e:
        logger.error(f"获取设备拓扑失败: {str(e)}")
        return APIResponse(
            success=False,
            message="服务器内部错误",
            error_code=ERROR_CODES["TOPOLOGY_BUILD_FAILED"]
        ).to_dict(), 500
```

**响应示例**

```json
{
  "success": true,
  "data": {
    "topology": {
      "nodes": [
        {
          "id": "device_1",
          "label": "主配电柜A",
          "type": "配电柜",
          "station": "A区机房",
          "position": {"x": 100, "y": 50},
          "layer": 1,
          "style": "critical",
          "is_critical": true,
          "properties": {
            "asset_id": "PDU-001",
            "model": "ABB-8000A",
            "power_rating": "8000A",
            "vendor": "ABB",
            "room_name": "A区配电间",
            "system_name": "高压配电系统"
          }
        }
      ],
      "edges": [
        {
          "id": "conn_1",
          "from": "device_1",
          "to": "device_2",
          "type": "cable",
          "hierarchy": "上级供电",
          "direction": "forward",
          "properties": {
            "cable_model": "YJV-4x240",
            "rated_current": "400A",
            "cable_length": "50m"
          }
        }
      ],
      "layout": {
        "algorithm": "hierarchical",
        "direction": "UD"
      }
    },
    "metadata": {
      "total_nodes": 25,
      "total_edges": 30,
      "layout_algorithm": "hierarchical",
      "generated_at": "2024-01-15T10:30:00"
    }
  },
  "message": "拓扑数据获取成功",
  "timestamp": "2024-01-15T10:30:00.123Z"
}
```

#### 4.2.2 更新设备拓扑位置

**接口定义**

```
PUT /api/v1/topology/devices/positions
```

**请求体**

```python
class UpdatePositionsRequest:
    positions: List[Dict] = [
        {
            "device_id": "device_1",
            "x": 100,
            "y": 200,
            "layer": 1
        }
    ]
```

**API实现**

```python
class UpdatePositionsSchema(Schema):
    positions = fields.List(fields.Dict(keys=fields.Str(), values=fields.Raw()), required=True)

@topology_bp.route('/devices/positions', methods=['PUT'])
@require_auth
@require_permission('topology:write')
def update_device_positions():
    """更新设备拓扑位置"""
    schema = UpdatePositionsSchema()

    try:
        data = schema.load(request.get_json())
        positions = data['positions']

        session = SessionLocal()
        updated_count = 0

        for pos in positions:
            device_id = pos.get('device_id')
            if device_id and device_id.startswith('device_'):
                actual_id = int(device_id.replace('device_', ''))

                device = session.query(Device).filter(Device.id == actual_id).first()
                if device:
                    device.topology_x = pos.get('x')
                    device.topology_y = pos.get('y')
                    device.topology_layer = pos.get('layer', 0)
                    updated_count += 1

        session.commit()
        session.close()

        return APIResponse(
            success=True,
            data={"updated_count": updated_count},
            message=f"成功更新{updated_count}个设备位置"
        ).to_dict()

    except Exception as e:
        logger.error(f"更新设备位置失败: {str(e)}")
        return APIResponse(
            success=False,
            message="更新失败",
            error_code=ERROR_CODES["DATABASE_ERROR"]
        ).to_dict(), 500
```

### 4.3 端口级拓扑图API

#### 4.3.1 获取端口拓扑数据

**接口定义**

```
GET /api/v1/topology/ports
```

**请求参数**

```python
class PortTopologyRequest:
    device_ids: Optional[List[int]] = None     # 设备ID列表
    port_types: Optional[List[str]] = None     # 端口类型筛选
    connection_status: Optional[str] = None    # 连接状态筛选
    include_unused_ports: bool = False         # 是否包含未使用端口
```

**API实现**

```python
class PortTopologyRequestSchema(Schema):
    device_ids = fields.List(fields.Int(), missing=None)
    port_types = fields.List(fields.Str(), missing=None)
    connection_status = fields.Str(missing=None, validate=lambda x: x in ['connected', 'disconnected', None])
    include_unused_ports = fields.Bool(missing=False)

@topology_bp.route('/ports', methods=['GET'])
@require_auth
@require_permission('topology:read')
def get_port_topology():
    """获取端口级拓扑图数据"""
    schema = PortTopologyRequestSchema()

    try:
        params = schema.load(request.args)

        # 构建端口拓扑数据
        topology_data = build_port_topology(
            device_ids=params['device_ids'],
            port_types=params['port_types'],
            connection_status=params['connection_status']
        )

        # 过滤未使用端口
        if not params['include_unused_ports']:
            for device in topology_data['devices']:
                device['ports'] = [
                    port for port in device['ports'] 
                    if port['status'] != 'unused'
                ]

        response_data = {
            "topology": topology_data,
            "metadata": {
                "total_devices": len(topology_data['devices']),
                "total_connections": len(topology_data['connections']),
                "generated_at": datetime.now().isoformat()
            }
        }

        return APIResponse(
            success=True,
            data=response_data,
            message="端口拓扑数据获取成功"
        ).to_dict()

    except Exception as e:
        logger.error(f"获取端口拓扑失败: {str(e)}")
        return APIResponse(
            success=False,
            message="服务器内部错误",
            error_code=ERROR_CODES["TOPOLOGY_BUILD_FAILED"]
        ).to_dict(), 500
```

### 4.4 路径分析API

#### 4.4.1 最短路径分析

**接口定义**

```
POST /api/v1/topology/analysis/path
```

**请求体**

```python
class PathAnalysisRequest:
    source_device_id: int
    target_device_id: int
    max_paths: int = 5
    analysis_type: str = "shortest"  # shortest, reliable, capacity
    constraints: Optional[Dict] = None
```

**API实现**

```python
class PathAnalysisSchema(Schema):
    source_device_id = fields.Int(required=True)
    target_device_id = fields.Int(required=True)
    max_paths = fields.Int(missing=5, validate=lambda x: 1 <= x <= 10)
    analysis_type = fields.Str(missing="shortest", validate=lambda x: x in ['shortest', 'reliable', 'capacity'])
    constraints = fields.Dict(missing=None)

@topology_bp.route('/analysis/path', methods=['POST'])
@require_auth
@require_permission('topology:analyze')
def analyze_path():
    """路径分析"""
    schema = PathAnalysisSchema()

    try:
        data = schema.load(request.get_json())

        # 执行路径分析
        result = find_shortest_path(
            source_device_id=data['source_device_id'],
            target_device_id=data['target_device_id'],
            max_paths=data['max_paths']
        )

        if not result['paths']:
            return APIResponse(
                success=False,
                message="未找到有效路径",
                error_code=ERROR_CODES["PATH_NOT_FOUND"]
            ).to_dict(), 404

        return APIResponse(
            success=True,
            data=result,
            message="路径分析完成"
        ).to_dict()

    except Exception as e:
        logger.error(f"路径分析失败: {str(e)}")
        return APIResponse(
            success=False,
            message="分析失败",
            error_code=ERROR_CODES["ANALYSIS_FAILED"]
        ).to_dict(), 500
```

### 4.5 故障影响分析API

#### 4.5.1 故障影响分析

**接口定义**

```
POST /api/v1/topology/analysis/failure
```

**API实现**

```python
class FailureAnalysisSchema(Schema):
    failed_device_id = fields.Int(required=True)
    failure_type = fields.Str(missing="complete", validate=lambda x: x in ['complete', 'partial', 'maintenance'])
    analysis_scope = fields.Str(missing="extended", validate=lambda x: x in ['immediate', 'extended', 'full'])

@topology_bp.route('/analysis/failure', methods=['POST'])
@require_auth
@require_permission('topology:analyze')
def analyze_failure():
    """故障影响分析"""
    schema = FailureAnalysisSchema()

    try:
        data = schema.load(request.get_json())

        # 执行故障影响分析
        result = analyze_failure_impact(
            failed_device_id=data['failed_device_id'],
            failure_type=data['failure_type'],
            analysis_scope=data['analysis_scope']
        )

        if 'error' in result:
            return APIResponse(
                success=False,
                message=result['error'],
                error_code=ERROR_CODES["DEVICE_NOT_FOUND"]
            ).to_dict(), 404

        return APIResponse(
            success=True,
            data=result,
            message="故障影响分析完成"
        ).to_dict()

    except Exception as e:
        logger.error(f"故障影响分析失败: {str(e)}")
        return APIResponse(
            success=False,
            message="分析失败",
            error_code=ERROR_CODES["ANALYSIS_FAILED"]
        ).to_dict(), 500
```

### 4.6 错误处理和状态码

#### 4.6.1 HTTP状态码规范

```python
# HTTP状态码使用规范
HTTP_STATUS_CODES = {
    200: "请求成功",
    201: "资源创建成功", 
    400: "请求参数错误",
    401: "未授权访问",
    403: "权限不足",
    404: "资源不存在",
    409: "资源冲突",
    429: "请求频率超限",
    500: "服务器内部错误",
    503: "服务不可用"
}
```

#### 4.6.2 全局错误处理

```python
@topology_bp.errorhandler(ValidationError)
def handle_validation_error(e):
    return APIResponse(
        success=False,
        message="参数验证失败",
        error_code=ERROR_CODES["INVALID_PARAMETERS"],
        data={"validation_errors": e.messages}
    ).to_dict(), 400

@topology_bp.errorhandler(Exception)
def handle_general_error(e):
    logger.error(f"未处理的异常: {str(e)}")
    return APIResponse(
        success=False,
        message="服务器内部错误",
        error_code=ERROR_CODES["DATABASE_ERROR"]
    ).to_dict(), 500
```

### 4.7 API测试用例

#### 4.7.1 设备拓扑API测试

```python
import pytest
import json
from unittest.mock import patch, MagicMock
from app import app

class TestTopologyAPI:
    """拓扑图API测试类"""

    @pytest.fixture
    def client(self):
        """测试客户端"""
        app.config['TESTING'] = True
        with app.test_client() as client:
            yield client

    def test_get_device_topology_success(self, client):
        """测试获取设备拓扑成功"""
        # 模拟数据
        mock_data = {
            'nodes': [
                {
                    'id': 'device_001',
                    'label': '主变压器',
                    'type': 'transformer',
                    'status': 'online',
                    'properties': {
                        'power_rating': 1000,
                        'location': '机房A'
                    }
                }
            ],
            'edges': [
                {
                    'id': 'edge_001_002',
                    'from': 'device_001',
                    'to': 'device_002',
                    'type': 'cable',
                    'properties': {
                        'cable_length': 50,
                        'rated_current': 100
                    }
                }
            ]
        }

        with patch('topology_service.build_device_topology') as mock_build:
            mock_build.return_value = mock_data

            response = client.get('/api/v1/topology/devices')

            assert response.status_code == 200
            data = json.loads(response.data)
            assert data['success'] is True
            assert 'nodes' in data['data']
            assert 'edges' in data['data']
            assert len(data['data']['nodes']) == 1
            assert data['data']['nodes'][0]['id'] == 'device_001'

    def test_get_device_topology_with_filters(self, client):
        """测试带筛选条件的设备拓扑获取"""
        response = client.get('/api/v1/topology/devices?device_types=transformer,switchgear&status=online')

        assert response.status_code == 200
        data = json.loads(response.data)
        assert data['success'] is True

    def test_get_device_topology_invalid_params(self, client):
        """测试无效参数"""
        response = client.get('/api/v1/topology/devices?invalid_param=test')

        assert response.status_code == 400
        data = json.loads(response.data)
        assert data['success'] is False
        assert data['error_code'] == 1002

    def test_get_port_topology_success(self, client):
        """测试获取端口拓扑成功"""
        mock_data = {
            'nodes': [
                {
                    'id': 'device_001',
                    'label': '交换机A',
                    'type': 'device',
                    'ports': [
                        {
                            'id': 'port_001',
                            'label': 'Port 1',
                            'type': 'ethernet',
                            'status': 'connected'
                        }
                    ]
                }
            ],
            'edges': []
        }

        with patch('topology_service.build_port_topology') as mock_build:
            mock_build.return_value = mock_data

            response = client.get('/api/v1/topology/ports')

            assert response.status_code == 200
            data = json.loads(response.data)
            assert data['success'] is True
            assert 'nodes' in data['data']

    def test_path_analysis_success(self, client):
        """测试路径分析成功"""
        request_data = {
            'source_device_id': 'device_001',
            'target_device_id': 'device_002',
            'analysis_type': 'shortest'
        }

        mock_result = {
            'paths': [
                {
                    'path_id': 'shortest_device_001_device_002',
                    'nodes': ['device_001', 'device_002'],
                    'total_weight': 10.5,
                    'reliability_score': 0.95
                }
            ],
            'analysis_summary': {
                'path_count': 1,
                'average_reliability': 0.95
            }
        }

        with patch('topology_service.analyze_paths') as mock_analyze:
            mock_analyze.return_value = mock_result

            response = client.post('/api/v1/topology/analysis/paths',
                                 data=json.dumps(request_data),
                                 content_type='application/json')

            assert response.status_code == 200
            data = json.loads(response.data)
            assert data['success'] is True
            assert 'paths' in data['data']

    def test_failure_analysis_success(self, client):
        """测试故障影响分析成功"""
        request_data = {
            'failed_device_id': 'device_001',
            'failure_type': 'complete'
        }

        mock_result = {
            'impact_summary': {
                'affected_devices': 5,
                'critical_devices': 2,
                'estimated_downtime': {
                    'estimated_hours': 4.2,
                    'confidence_level': 0.8
                },
                'risk_level': 'high'
            },
            'affected_devices': [],
            'recommendations': []
        }

        with patch('topology_service.analyze_failure_impact') as mock_analyze:
            mock_analyze.return_value = mock_result

            response = client.post('/api/v1/topology/analysis/failure',
                                 data=json.dumps(request_data),
                                 content_type='application/json')

            assert response.status_code == 200
            data = json.loads(response.data)
            assert data['success'] is True
            assert 'impact_summary' in data['data']

    def test_database_error_handling(self, client):
        """测试数据库错误处理"""
        with patch('topology_service.build_device_topology') as mock_build:
            mock_build.side_effect = Exception('Database connection failed')

            response = client.get('/api/v1/topology/devices')

            assert response.status_code == 500
            data = json.loads(response.data)
            assert data['success'] is False
            assert data['error_code'] == 1003

    def test_rate_limiting(self, client):
        """测试API限流"""
        # 模拟大量请求
        responses = []
        for i in range(100):
            response = client.get('/api/v1/topology/devices')
            responses.append(response.status_code)

        # 检查是否有429状态码（请求过多）
        assert 429 in responses

#### 4.7.2 性能测试用例

```python
import time
import concurrent.futures
from locust import HttpUser, task, between

class TopologyAPIPerformanceTest(HttpUser):
    """拓扑图API性能测试"""

    wait_time = between(1, 3)

    @task(3)
    def get_device_topology(self):
        """获取设备拓扑性能测试"""
        self.client.get('/api/v1/topology/devices')

    @task(2)
    def get_port_topology(self):
        """获取端口拓扑性能测试"""
        self.client.get('/api/v1/topology/ports')

    @task(1)
    def path_analysis(self):
        """路径分析性能测试"""
        self.client.post('/api/v1/topology/analysis/paths', json={
            'source_device_id': 'device_001',
            'target_device_id': 'device_002',
            'analysis_type': 'shortest'
        })

def test_api_response_time():
    """测试API响应时间"""
    import requests

    start_time = time.time()
    response = requests.get('http://localhost:8000/api/v1/topology/devices')
    end_time = time.time()

    response_time = end_time - start_time

    assert response.status_code == 200
    assert response_time < 2.0  # 响应时间应小于2秒

def test_concurrent_requests():
    """测试并发请求处理"""
    import requests

    def make_request():
        return requests.get('http://localhost:8000/api/v1/topology/devices')

    # 并发50个请求
    with concurrent.futures.ThreadPoolExecutor(max_workers=50) as executor:
        futures = [executor.submit(make_request) for _ in range(50)]
        results = [future.result() for future in concurrent.futures.as_completed(futures)]

    # 检查所有请求都成功
    success_count = sum(1 for result in results if result.status_code == 200)
    assert success_count >= 45  # 至少90%的请求成功
```

#### 4.7.3 集成测试用例

```python
class TestTopologyIntegration:
    """拓扑图集成测试"""

    def test_end_to_end_workflow(self, client, db_session):
        """端到端工作流测试"""
        # 1. 创建测试数据
        device1 = Device(device_id='test_001', device_name='测试设备1', device_type='transformer')
        device2 = Device(device_id='test_002', device_name='测试设备2', device_type='switchgear')
        connection = Connection(
            source_device_id='test_001',
            target_device_id='test_002',
            connection_type='cable'
        )

        db_session.add_all([device1, device2, connection])
        db_session.commit()

        # 2. 获取拓扑数据
        response = client.get('/api/v1/topology/devices')
        assert response.status_code == 200

        data = json.loads(response.data)
        assert len(data['data']['nodes']) >= 2
        assert len(data['data']['edges']) >= 1

        # 3. 执行路径分析
        path_response = client.post('/api/v1/topology/analysis/paths', json={
            'source_device_id': 'test_001',
            'target_device_id': 'test_002',
            'analysis_type': 'shortest'
        })
        assert path_response.status_code == 200

        # 4. 执行故障分析
        failure_response = client.post('/api/v1/topology/analysis/failure', json={
            'failed_device_id': 'test_001',
            'failure_type': 'complete'
        })
        assert failure_response.status_code == 200

        # 5. 清理测试数据
        db_session.delete(connection)
        db_session.delete(device1)
        db_session.delete(device2)
        db_session.commit()
```import pytest
import json
from app import create_app

class TestDeviceTopologyAPI:

    def setup_method(self):
        self.app = create_app('testing')
        self.client = self.app.test_client()
        self.auth_headers = self.get_auth_headers()

    def test_get_device_topology_success(self):
        """测试成功获取设备拓扑"""
        response = self.client.get(
            '/api/v1/topology/devices',
            headers=self.auth_headers
        )

        assert response.status_code == 200
        data = json.loads(response.data)
        assert data['success'] is True
        assert 'topology' in data['data']
        assert 'nodes' in data['data']['topology']
        assert 'edges' in data['data']['topology']

    def test_get_device_topology_with_filters(self):
        """测试带筛选条件的设备拓扑"""
        response = self.client.get(
            '/api/v1/topology/devices?location_filter=A区&device_type_filter=配电柜',
            headers=self.auth_headers
        )

        assert response.status_code == 200
        data = json.loads(response.data)
        assert data['success'] is True

    def test_get_device_topology_invalid_params(self):
        """测试无效参数"""
        response = self.client.get(
            '/api/v1/topology/devices?max_nodes=10000',  # 超过限制
            headers=self.auth_headers
        )

        assert response.status_code == 400
        data = json.loads(response.data)
        assert data['success'] is False
        assert data['error_code'] == 1002

    def test_update_device_positions(self):
        """测试更新设备位置"""
        positions_data = {
            "positions": [
                {"device_id": "device_1", "x": 100, "y": 200, "layer": 1},
                {"device_id": "device_2", "x": 300, "y": 400, "layer": 1}
            ]
        }

        response = self.client.put(
            '/api/v1/topology/devices/positions',
            data=json.dumps(positions_data),
            content_type='application/json',
            headers=self.auth_headers
        )

        assert response.status_code == 200
        data = json.loads(response.data)
        assert data['success'] is True
        assert data['data']['updated_count'] >= 0
```

#### 4.7.2 路径分析API测试

```python
class TestPathAnalysisAPI:

    def test_path_analysis_success(self):
        """测试成功的路径分析"""
        analysis_data = {
            "source_device_id": 1,
            "target_device_id": 5,
            "max_paths": 3,
            "analysis_type": "shortest"
        }

        response = self.client.post(
            '/api/v1/topology/analysis/path',
            data=json.dumps(analysis_data),
            content_type='application/json',
            headers=self.auth_headers
        )

        assert response.status_code == 200
        data = json.loads(response.data)
        assert data['success'] is True
        assert 'paths' in data['data']
        assert 'analysis_summary' in data['data']

    def test_path_analysis_no_path_found(self):
        """测试未找到路径的情况"""
        analysis_data = {
            "source_device_id": 999,  # 不存在的设备
            "target_device_id": 1000,
            "max_paths": 3
        }

        response = self.client.post(
            '/api/v1/topology/analysis/path',
            data=json.dumps(analysis_data),
            content_type='application/json',
            headers=self.auth_headers
        )

        assert response.status_code == 404
        data = json.loads(response.data)
        assert data['success'] is False
        assert data['error_code'] == 1005
```

### 4.8 API性能优化

#### 4.8.1 缓存策略

```python
from flask_caching import Cache
from functools import wraps

cache = Cache()

def cache_topology_data(timeout=300):
    """拓扑数据缓存装饰器"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            # 生成缓存键
            cache_key = f"topology_{f.__name__}_{hash(str(args) + str(kwargs))}"

            # 尝试从缓存获取
            cached_result = cache.get(cache_key)
            if cached_result:
                return cached_result

            # 执行函数并缓存结果
            result = f(*args, **kwargs)
            cache.set(cache_key, result, timeout=timeout)
            return result

        return decorated_function
    return decorator

# 使用缓存
@cache_topology_data(timeout=600)
def build_device_topology_cached(*args, **kwargs):
    return build_device_topology(*args, **kwargs)
```

#### 4.8.2 分页和限制

```python
class PaginationSchema(Schema):
    page = fields.Int(missing=1, validate=lambda x: x >= 1)
    per_page = fields.Int(missing=50, validate=lambda x: 1 <= x <= 1000)
    sort_by = fields.Str(missing="id")
    sort_order = fields.Str(missing="asc", validate=lambda x: x in ['asc', 'desc'])

def paginate_results(query, page, per_page):
    """分页查询结果"""
    total = query.count()
    items = query.offset((page - 1) * per_page).limit(per_page).all()

    return {
        "items": items,
        "pagination": {
            "page": page,
            "per_page": per_page,
            "total": total,
            "pages": (total + per_page - 1) // per_page
        }
    }
```

#### 3.1.1 基础配置

- **基础URL**: `http://localhost:8000/api/v1`
- **认证方式**: JWT Token
- **数据格式**: JSON
- **字符编码**: UTF-8
- **API版本**: v1.0

#### 3.1.2 通用响应格式

**成功响应：**

```json
{
  "success": true,
  "code": 200,
  "message": "操作成功",
  "data": {},
  "timestamp": "2025-01-16T10:30:00Z",
  "request_id": "req_123456789"
}
```

**错误响应：**

```json
{
  "success": false,
  "code": 400,
  "message": "请求参数错误",
  "error": {
    "type": "ValidationError",
    "details": "device_id字段不能为空"
  },
  "timestamp": "2025-01-16T10:30:00Z",
  "request_id": "req_123456789"
}
```

### 3.2 设备级拓扑图API

#### 3.2.1 获取设备拓扑数据

**接口路径**: `GET /topology/device-level/graph`

**请求参数**:

```json
{
  "location": "string",      // 可选，位置筛选
  "device_type": "string",   // 可选，设备类型筛选
  "include_offline": "boolean", // 可选，是否包含离线设备
  "max_depth": "number"      // 可选，最大层级深度
}
```

**响应数据**:

```json
{
  "nodes": [
    {
      "id": "device_001",
      "label": "UPS-001",
      "type": "ups",
      "status": "online",
      "position": {"x": 100, "y": 200},
      "properties": {
        "rated_power": 10000,
        "current_load": 7500
      }
    }
  ],
  "edges": [
    {
      "id": "conn_001",
      "from": "device_001",
      "to": "device_002",
      "type": "power",
      "direction": "forward",
      "properties": {
        "rated_current": 100,
        "actual_current": 75
      }
    }
  ],
  "layout": {
    "algorithm": "hierarchical",
    "direction": "UD"
  }
}
```

#### 3.2.2 路径分析

**接口路径**: `POST /topology/device-level/path-analysis`

**请求参数**:

```json
{
  "source_device_id": "string",
  "target_device_id": "string",
  "analysis_type": "string",    // shortest/all/critical
  "max_paths": "number"         // 最大路径数量
}
```

**响应数据**:

```json
{
  "paths": [
    {
      "path_id": "path_001",
      "devices": ["device_001", "device_002", "device_003"],
      "connections": ["conn_001", "conn_002"],
      "total_length": 3,
      "reliability_score": 0.95,
      "power_capacity": 8000
    }
  ],
  "analysis_summary": {
    "total_paths": 2,
    "recommended_path": "path_001",
    "risk_assessment": "low"
  }
}
```

#### 3.2.3 故障影响分析

**接口路径**: `POST /topology/device-level/impact-analysis`

**请求参数**:

```json
{
  "failed_device_id": "string",
  "failure_type": "string",     // complete/partial/maintenance
  "analysis_scope": "string"    // immediate/extended/full
}
```

**响应数据**:

```json
{
  "impact_summary": {
    "affected_devices": 15,
    "critical_devices": 3,
    "estimated_downtime": "2h",
    "risk_level": "high"
  },
  "affected_devices": [
    {
      "device_id": "device_002",
      "device_name": "服务器机柜A",
      "impact_type": "power_loss",
      "criticality": "high",
      "alternative_paths": 1
    }
  ],
  "recommendations": [
    {
      "action": "activate_backup_power",
      "priority": "immediate",
      "description": "启动备用电源系统"
    }
  ]
}
```

### 3.3 端口级拓扑图API

#### 3.3.1 获取端口拓扑数据

**接口路径**: `GET /topology/port-level/graph`

**请求参数**:

```json
{
  "device_ids": ["string"],     // 可选，设备ID列表
  "port_types": ["string"],     // 可选，端口类型筛选
  "connection_status": "string", // 可选，连接状态筛选
  "include_details": "boolean"   // 可选，是否包含详细信息
}
```

**响应数据**:

```json
{
  "devices": [
    {
      "device_id": "device_001",
      "device_name": "交换机-001",
      "ports": [
        {
          "port_id": "port_001",
          "port_name": "GE0/0/1",
          "port_type": "ethernet",
          "status": "connected",
          "position": {"x": 10, "y": 20}
        }
      ]
    }
  ],
  "connections": [
    {
      "connection_id": "conn_001",
      "from_port": "port_001",
      "to_port": "port_002",
      "connection_type": "ethernet",
      "status": "active"
    }
  ]
}
```

#### 3.3.2 端口搜索

**接口路径**: `GET /topology/port-level/search`

**请求参数**:

```json
{
  "keyword": "string",          // 搜索关键词
  "search_fields": ["string"],  // 搜索字段
  "filters": {
    "device_type": "string",
    "port_type": "string",
    "status": "string"
  },
  "page": "number",
  "page_size": "number"
}
```

#### 3.3.3 批量端口操作

**接口路径**: `POST /topology/port-level/batch-update`

**请求参数**:

```json
{
  "operation": "string",        // update/enable/disable/delete
  "port_ids": ["string"],
  "update_data": {
    "status": "string",
    "description": "string"
  }
}
```

### 3.4 共享基础API

#### 3.4.1 设备管理API

**获取设备列表**: `GET /devices`
**获取设备详情**: `GET /devices/{device_id}`
**创建设备**: `POST /devices`
**更新设备**: `PUT /devices/{device_id}`
**删除设备**: `DELETE /devices/{device_id}`

#### 3.4.2 连接管理API

**获取连接列表**: `GET /connections`
**获取连接详情**: `GET /connections/{connection_id}`
**创建连接**: `POST /connections`
**更新连接**: `PUT /connections/{connection_id}`
**删除连接**: `DELETE /connections/{connection_id}`

#### 3.4.3 统计分析API

**设备统计**: `GET /statistics/devices`
**连接统计**: `GET /statistics/connections`
**性能指标**: `GET /statistics/performance`

### 3.5 错误处理和状态码

#### 3.5.1 HTTP状态码

- `200 OK`: 请求成功
- `201 Created`: 资源创建成功
- `400 Bad Request`: 请求参数错误
- `401 Unauthorized`: 未授权访问
- `403 Forbidden`: 禁止访问
- `404 Not Found`: 资源不存在
- `409 Conflict`: 资源冲突
- `422 Unprocessable Entity`: 数据验证失败
- `500 Internal Server Error`: 服务器内部错误

#### 3.5.2 业务错误码

```json
{
  "DEVICE_NOT_FOUND": {
    "code": "D001",
    "message": "设备不存在"
  },
  "PORT_ALREADY_CONNECTED": {
    "code": "P001",
    "message": "端口已被连接"
  },
  "INVALID_CONNECTION": {
    "code": "C001",
    "message": "无效的连接配置"
  }
}
```

## 4. 统一UI设计规范

### 4.1 视觉设计语言

#### 4.1.1 配色方案

**主色调：**

- 主色：#1890ff (蓝色)
- 辅助色：#52c41a (绿色)
- 警告色：#faad14 (橙色)
- 错误色：#f5222d (红色)
- 中性色：#8c8c8c (灰色)

**设备状态颜色：**

- 在线：#52c41a (绿色)
- 离线：#8c8c8c (灰色)
- 故障：#f5222d (红色)
- 维护：#faad14 (橙色)

**连接状态颜色：**

- 正常：#1890ff (蓝色)
- 异常：#f5222d (红色)
- 维护：#faad14 (橙色)
- 未连接：#d9d9d9 (浅灰)

#### 4.1.2 设备节点设计

**节点形状规范：**

- UPS：矩形，圆角4px
- 配电柜：矩形，圆角2px
- 服务器：矩形，圆角6px
- 网络设备：圆形
- 传感器：菱形

**节点大小规范：**

- 小型设备：40x30px
- 中型设备：60x45px
- 大型设备：80x60px

**节点标签：**

- 字体：12px, 微软雅黑
- 颜色：#262626
- 位置：节点下方，居中对齐

#### 4.1.3 连接线设计

**线条样式：**

- 电力连接：实线，宽度2-4px
- 数据连接：虚线，宽度1-2px
- 控制连接：点线，宽度1px

**箭头设计：**

- 单向：三角形箭头
- 双向：双向箭头
- 聚合：粗箭头

**线条颜色：**

- 按连接类型区分
- 支持状态颜色覆盖

### 4.2 交互设计标准

#### 4.2.1 鼠标交互

**节点交互：**

- 悬停：显示详细信息卡片
- 单击：选中节点，显示属性面板
- 双击：进入节点详情页面
- 右键：显示上下文菜单

**连接线交互：**

- 悬停：高亮连接，显示连接信息
- 单击：选中连接，显示属性面板
- 双击：编辑连接属性
- 右键：显示连接操作菜单

**画布交互：**

- 拖拽：平移视图
- 滚轮：缩放视图
- 框选：多选节点
- 右键：显示画布菜单

#### 4.2.2 键盘快捷键

- `Ctrl+A`: 全选
- `Ctrl+C`: 复制
- `Ctrl+V`: 粘贴
- `Delete`: 删除选中项
- `Ctrl+Z`: 撤销
- `Ctrl+Y`: 重做
- `Ctrl+F`: 搜索
- `Ctrl+S`: 保存

#### 4.2.3 触摸交互（移动端）

- 单指拖拽：平移视图
- 双指缩放：缩放视图
- 单击：选中
- 长按：显示上下文菜单

### 4.3 布局设计规范

#### 4.3.1 整体布局

```
+------------------+------------------+
|    工具栏区域     |    控制面板区域   |
+------------------+------------------+
|                                    |
|            画布区域                 |
|                                    |
+------------------------------------+
|            状态栏区域               |
+------------------------------------+
```

#### 4.3.2 工具栏设计

**工具分组：**

1. 视图控制：缩放、适应、重置
2. 选择工具：选择、框选、套索
3. 编辑工具：添加、删除、连接
4. 布局工具：自动布局、手动布局
5. 导出工具：图片、PDF、数据

#### 4.3.3 控制面板设计

**面板分类：**

1. 图层控制：显示/隐藏不同类型的元素
2. 筛选控制：按条件筛选显示内容
3. 属性面板：显示选中元素的详细信息
4. 搜索面板：搜索和定位元素

### 4.4 响应式设计

#### 4.4.1 断点设置

- 超大屏：≥1920px
- 大屏：1200px-1919px
- 中屏：768px-1199px
- 小屏：576px-767px
- 超小屏：<576px

#### 4.4.2 适配策略

**大屏适配：**

- 显示完整的工具栏和控制面板
- 支持多窗口和分屏操作
- 提供详细的信息展示

**中屏适配：**

- 简化工具栏，保留核心功能
- 控制面板可折叠
- 优化信息密度

**小屏适配：**

- 工具栏改为下拉菜单
- 控制面板改为抽屉式
- 简化交互方式

## 5. 技术架构设计

### 5.1 整体架构

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   前端展示层     │    │   API网关层      │    │   业务逻辑层     │
├─────────────────┤    ├─────────────────┤    ├─────────────────┤
│ 设备级拓扑图     │    │ 路由管理        │    │ 拓扑计算服务     │
│ 端口级拓扑图     │    │ 认证授权        │    │ 数据处理服务     │
│ 统一UI组件      │    │ 限流控制        │    │ 分析计算服务     │
│ 交互控制器      │    │ 日志记录        │    │ 缓存管理服务     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   数据访问层     │    │   数据存储层     │    │   外部集成层     │
├─────────────────┤    ├─────────────────┤    ├─────────────────┤
│ ORM映射         │    │ 关系数据库      │    │ 设备管理系统     │
│ 缓存访问        │    │ 图数据库        │    │ 监控系统        │
│ 搜索引擎        │    │ 缓存数据库      │    │ 工单系统        │
│ 消息队列        │    │ 文件存储        │    │ 通知系统        │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 5.2 技术选型

#### 5.2.1 前端技术栈

- **框架**: Vue.js 3.x
- **UI库**: Ant Design Vue
- **可视化**: vis.js + D3.js
- **状态管理**: Pinia
- **路由**: Vue Router
- **HTTP客户端**: Axios
- **构建工具**: Vite
- **类型检查**: TypeScript

#### 5.2.2 后端技术栈

- **框架**: Django 4.x
- **API框架**: Django REST Framework
- **数据库**: PostgreSQL + Neo4j
- **缓存**: Redis
- **搜索**: Elasticsearch
- **消息队列**: Celery + RabbitMQ
- **认证**: JWT
- **文档**: Swagger/OpenAPI

#### 5.2.3 部署技术栈

- **容器化**: Docker + Docker Compose
- **编排**: Kubernetes
- **负载均衡**: Nginx
- **监控**: Prometheus + Grafana
- **日志**: ELK Stack
- **CI/CD**: GitLab CI

## 6. 前端实现规范

### 6.1 技术栈选择

#### 6.1.1 核心技术栈

```javascript
// package.json 依赖配置
{
  "dependencies": {
    "vue": "^3.3.0",
    "vue-router": "^4.2.0",
    "pinia": "^2.1.0",
    "vis-network": "^9.1.0",
    "vis-data": "^7.1.0",
    "axios": "^1.4.0",
    "element-plus": "^2.3.0",
    "@element-plus/icons-vue": "^2.1.0",
    "lodash-es": "^4.17.21",
    "d3": "^7.8.0"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^4.2.0",
    "vite": "^4.3.0",
    "typescript": "^5.0.0",
    "@vue/tsconfig": "^0.4.0",
    "eslint": "^8.39.0",
    "prettier": "^2.8.8"
  }
}
```

#### 6.1.2 项目结构规范

```
src/
├── components/           # 通用组件
│   ├── topology/        # 拓扑图相关组件
│   │   ├── TopologyCanvas.vue      # 拓扑图画布
│   │   ├── TopologyControls.vue    # 拓扑图控制面板
│   │   ├── TopologyLegend.vue      # 拓扑图图例
│   │   ├── NodeInfoPanel.vue       # 节点信息面板
│   │   └── PathAnalysisPanel.vue   # 路径分析面板
│   └── common/          # 通用组件
├── stores/              # Pinia状态管理
│   ├── topology.js      # 拓扑图状态
│   ├── devices.js       # 设备状态
│   └── analysis.js      # 分析状态
├── services/            # API服务
│   ├── topology.js      # 拓扑图API
│   ├── devices.js       # 设备API
│   └── analysis.js      # 分析API
├── utils/               # 工具函数
│   ├── topology-utils.js    # 拓扑图工具
│   ├── vis-config.js        # vis.js配置
│   └── performance.js       # 性能优化工具
├── views/               # 页面组件
│   ├── DeviceTopology.vue   # 设备级拓扑图
│   ├── PortTopology.vue     # 端口级拓扑图
│   └── TopologyAnalysis.vue # 拓扑分析页面
└── assets/              # 静态资源
    ├── icons/           # 设备图标
    └── styles/          # 样式文件
```

### 6.2 vis.js 详细配置

#### 6.2.1 网络配置

```javascript
// utils/vis-config.js
export const getNetworkOptions = (type = 'device') => {
  const baseOptions = {
    // 节点配置
    nodes: {
      shape: 'box',
      margin: 10,
      widthConstraint: {
        minimum: 80,
        maximum: 200
      },
      heightConstraint: {
        minimum: 40,
        maximum: 80
      },
      font: {
        size: 12,
        face: 'Microsoft YaHei',
        color: '#333333'
      },
      borderWidth: 2,
      shadow: {
        enabled: true,
        color: 'rgba(0,0,0,0.2)',
        size: 5,
        x: 2,
        y: 2
      },
      chosen: {
        node: function(values, id, selected, hovering) {
          values.borderWidth = 3;
          values.borderColor = '#2196F3';
        }
      }
    },

    // 边配置
    edges: {
      width: 2,
      color: {
        color: '#848484',
        highlight: '#2196F3',
        hover: '#2196F3'
      },
      arrows: {
        to: {
          enabled: true,
          scaleFactor: 1,
          type: 'arrow'
        }
      },
      smooth: {
        enabled: true,
        type: 'dynamic',
        roundness: 0.5
      },
      font: {
        size: 10,
        align: 'middle',
        background: 'rgba(255,255,255,0.8)',
        strokeWidth: 2,
        strokeColor: '#ffffff'
      }
    },

    // 布局配置
    layout: {
      hierarchical: {
        enabled: type === 'device',
        levelSeparation: 150,
        nodeSpacing: 100,
        treeSpacing: 200,
        blockShifting: true,
        edgeMinimization: true,
        parentCentralization: true,
        direction: 'UD',
        sortMethod: 'hubsize'
      },
      improvedLayout: true,
      clusterThreshold: 150
    },

    // 物理引擎配置
    physics: {
      enabled: type !== 'device',
      stabilization: {
        enabled: true,
        iterations: 1000,
        updateInterval: 25,
        onlyDynamicEdges: false,
        fit: true
      },
      barnesHut: {
        gravitationalConstant: -2000,
        centralGravity: 0.3,
        springLength: 95,
        springConstant: 0.04,
        damping: 0.09,
        avoidOverlap: 0.1
      },
      maxVelocity: 50,
      minVelocity: 0.1,
      solver: 'barnesHut',
      timestep: 0.35,
      adaptiveTimestep: true
    },

    // 交互配置
    interaction: {
      dragNodes: true,
      dragView: true,
      hideEdgesOnDrag: false,
      hideNodesOnDrag: false,
      hover: true,
      hoverConnectedEdges: true,
      keyboard: {
        enabled: true,
        speed: {x: 10, y: 10, zoom: 0.02},
        bindToWindow: false
      },
      multiselect: true,
      navigationButtons: true,
      selectable: true,
      selectConnectedEdges: true,
      tooltipDelay: 300,
      zoomView: true
    },

    // 操作配置
    manipulation: {
      enabled: false,
      initiallyActive: false
    },

    // 配置面板
    configure: {
      enabled: false
    }
  };

  return baseOptions;
};

// 设备类型样式配置
export const deviceStyles = {
  '配电柜': {
    color: {
      background: '#FF6B6B',
      border: '#E55353',
      highlight: {
        background: '#FF8E8E',
        border: '#E55353'
      }
    },
    shape: 'box',
    icon: {
      face: 'FontAwesome',
      code: '\uf0e7',
      size: 30,
      color: '#ffffff'
    }
  },
  'UPS': {
    color: {
      background: '#4ECDC4',
      border: '#45B7B8',
      highlight: {
        background: '#6BCCC4',
        border: '#45B7B8'
      }
    },
    shape: 'box',
    icon: {
      face: 'FontAwesome',
      code: '\uf240',
      size: 30,
      color: '#ffffff'
    }
  },
  '空调': {
    color: {
      background: '#45B7D1',
      border: '#3A9BC1',
      highlight: {
        background: '#6BB6D6',
        border: '#3A9BC1'
      }
    },
    shape: 'box',
    icon: {
      face: 'FontAwesome',
      code: '\uf2dc',
      size: 30,
      color: '#ffffff'
    }
  },
  '服务器': {
    color: {
      background: '#96CEB4',
      border: '#85C1A3',
      highlight: {
        background: '#A8D8C8',
        border: '#85C1A3'
      }
    },
    shape: 'box',
    icon: {
      face: 'FontAwesome',
      code: '\uf233',
      size: 30,
      color: '#ffffff'
    }
  },
  'default': {
    color: {
      background: '#FFEAA7',
      border: '#FDCB6E',
      highlight: {
        background: '#FFE4A3',
        border: '#FDCB6E'
      }
    },
    shape: 'box'
  }
};

// 连接类型样式配置
export const connectionStyles = {
  '电力线缆': {
    color: '#FF6B6B',
    width: 3,
    dashes: false
  },
  '网络线缆': {
    color: '#4ECDC4',
    width: 2,
    dashes: false
  },
  '控制线缆': {
    color: '#45B7D1',
    width: 2,
    dashes: [5, 5]
  },
  'default': {
    color: '#848484',
    width: 2,
    dashes: false
  }
};
```

#### 6.2.2 性能优化配置

```javascript
// utils/performance.js
export class TopologyPerformanceManager {
  constructor() {
    this.maxNodes = 1000;
    this.clusterThreshold = 50;
    this.renderThreshold = 100;
    this.updateDebounceTime = 300;
  }

  // 大数据量处理
  optimizeForLargeDataset(nodes, edges) {
    if (nodes.length > this.maxNodes) {
      return this.clusterNodes(nodes, edges);
    }

    if (nodes.length > this.renderThreshold) {
      return this.enableVirtualization(nodes, edges);
    }

    return { nodes, edges };
  }

  // 节点聚类
  clusterNodes(nodes, edges) {
    const clusteredNodes = [];
    const clusteredEdges = [];
    const clusters = this.groupNodesByLocation(nodes);

    Object.entries(clusters).forEach(([location, locationNodes]) => {
      if (locationNodes.length > this.clusterThreshold) {
        // 创建聚类节点
        const clusterNode = {
          id: `cluster_${location}`,
          label: `${location} (${locationNodes.length}个设备)`,
          shape: 'ellipse',
          color: {
            background: '#E8E8E8',
            border: '#CCCCCC'
          },
          font: { size: 14, color: '#666666' },
          mass: locationNodes.length
        };
        clusteredNodes.push(clusterNode);

        // 处理聚类边
        this.processClusterEdges(locationNodes, edges, clusteredEdges, clusterNode.id);
      } else {
        clusteredNodes.push(...locationNodes);
      }
    });

    return {
      nodes: clusteredNodes,
      edges: clusteredEdges
    };
  }

  // 虚拟化渲染
  enableVirtualization(nodes, edges) {
    return {
      nodes: nodes.map(node => ({
        ...node,
        hidden: false,
        physics: nodes.length > 500 ? false : true
      })),
      edges: edges.map(edge => ({
        ...edge,
        smooth: nodes.length > 300 ? false : { enabled: true, type: 'dynamic' }
      }))
    };
  }

  // 按位置分组节点
  groupNodesByLocation(nodes) {
    return nodes.reduce((groups, node) => {
      const location = node.station || '未知位置';
      if (!groups[location]) {
        groups[location] = [];
      }
      groups[location].push(node);
      return groups;
    }, {});
  }

  // 防抖更新
  debounceUpdate(callback, delay = this.updateDebounceTime) {
    let timeoutId;
    return function(...args) {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => callback.apply(this, args), delay);
    };
  }
}
```

### 6.3 Pinia状态管理

#### 6.3.1 拓扑图状态管理

```javascript
// stores/topology.js
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import { topologyAPI } from '@/services/topology';
import { TopologyPerformanceManager } from '@/utils/performance';

export const useTopologyStore = defineStore('topology', () => {
  // 状态
  const nodes = ref([]);
  const edges = ref([]);
  const selectedNodes = ref([]);
  const selectedEdges = ref([]);
  const viewMode = ref('device'); // 'device' | 'port'
  const layoutType = ref('hierarchical'); // 'hierarchical' | 'physics'
  const filters = ref({
    location: '',
    deviceType: '',
    includeOffline: true
  });
  const loading = ref(false);
  const error = ref(null);

  // 性能管理器
  const performanceManager = new TopologyPerformanceManager();

  // 计算属性
  const filteredNodes = computed(() => {
    return nodes.value.filter(node => {
      if (filters.value.location && !node.station?.includes(filters.value.location)) {
        return false;
      }
      if (filters.value.deviceType && node.type !== filters.value.deviceType) {
        return false;
      }
      if (!filters.value.includeOffline && node.status === 'offline') {
        return false;
      }
      return true;
    });
  });

  const networkData = computed(() => {
    const optimized = performanceManager.optimizeForLargeDataset(
      filteredNodes.value,
      edges.value
    );
    return {
      nodes: optimized.nodes,
      edges: optimized.edges
    };
  });

  const statistics = computed(() => {
    return {
      totalNodes: nodes.value.length,
      totalEdges: edges.value.length,
      onlineNodes: nodes.value.filter(n => n.status === 'online').length,
      offlineNodes: nodes.value.filter(n => n.status === 'offline').length,
      selectedCount: selectedNodes.value.length,
      deviceTypes: [...new Set(nodes.value.map(n => n.type))],
      locations: [...new Set(nodes.value.map(n => n.station).filter(Boolean))]
    };
  });

  // Actions
  const loadTopologyData = async (options = {}) => {
    loading.value = true;
    error.value = null;

    try {
      const startTime = performance.now();

      const response = viewMode.value === 'device' 
        ? await topologyAPI.getDeviceTopology(options)
        : await topologyAPI.getPortTopology(options);

      if (response.success) {
        nodes.value = response.data.nodes;
        edges.value = response.data.edges;

        // 记录性能指标
        performanceManager.recordLoadTime(
          performance.now() - startTime,
          nodes.value.length,
          edges.value.length
        );
      } else {
        throw new Error(response.message || '加载拓扑数据失败');
      }
    } catch (err) {
      error.value = err.message;
      console.error('Failed to load topology data:', err);
    } finally {
      loading.value = false;
    }
  };

  const selectNode = (nodeId) => {
    const index = selectedNodes.value.indexOf(nodeId);
    if (index > -1) {
      selectedNodes.value.splice(index, 1);
    } else {
      selectedNodes.value.push(nodeId);
    }
  };

  const selectMultipleNodes = (nodeIds) => {
    selectedNodes.value = [...new Set([...selectedNodes.value, ...nodeIds])];
  };

  const clearSelection = () => {
    selectedNodes.value = [];
    selectedEdges.value = [];
  };

  const updateFilters = (newFilters) => {
    filters.value = { ...filters.value, ...newFilters };
  };

  const switchViewMode = async (mode) => {
    if (viewMode.value !== mode) {
      viewMode.value = mode;
      clearSelection();
      await loadTopologyData();
    }
  };

  const updateLayout = (type) => {
    layoutType.value = type;
  };

  const getNodeById = (nodeId) => {
    return nodes.value.find(node => node.id === nodeId);
  };

  const getConnectedNodes = (nodeId) => {
    const connectedEdges = edges.value.filter(
      edge => edge.from === nodeId || edge.to === nodeId
    );

    const connectedNodeIds = connectedEdges.flatMap(edge => 
      edge.from === nodeId ? [edge.to] : [edge.from]
    );

    return nodes.value.filter(node => connectedNodeIds.includes(node.id));
  };

  const highlightPath = (sourceId, targetId) => {
    // 实现路径高亮逻辑
    const path = findShortestPath(sourceId, targetId);
    return path;
  };

  const findShortestPath = (sourceId, targetId) => {
    // Dijkstra算法实现
    const distances = {};
    const previous = {};
    const unvisited = new Set();

    // 初始化
    nodes.value.forEach(node => {
      distances[node.id] = node.id === sourceId ? 0 : Infinity;
      unvisited.add(node.id);
    });

    while (unvisited.size > 0) {
      // 找到距离最小的未访问节点
      const current = Array.from(unvisited).reduce((min, nodeId) => 
        distances[nodeId] < distances[min] ? nodeId : min
      );

      if (current === targetId) break;

      unvisited.delete(current);

      // 更新邻居节点距离
      const neighbors = getConnectedNodes(current);
      neighbors.forEach(neighbor => {
        if (unvisited.has(neighbor.id)) {
          const edge = edges.value.find(e => 
            (e.from === current && e.to === neighbor.id) ||
            (e.to === current && e.from === neighbor.id)
          );

          const weight = edge?.weight || 1;
          const newDistance = distances[current] + weight;

          if (newDistance < distances[neighbor.id]) {
            distances[neighbor.id] = newDistance;
            previous[neighbor.id] = current;
          }
        }
      });
    }

    // 重建路径
    const path = [];
    let current = targetId;
    while (current !== undefined) {
      path.unshift(current);
      current = previous[current];
    }

    return path[0] === sourceId ? path : [];
  };

  return {
    // State
    nodes,
    edges,
    selectedNodes,
    selectedEdges,
    viewMode,
    layoutType,
    filters,
    loading,
    error,

    // Computed
    filteredNodes,
    networkData,
    statistics,

    // Actions
    loadTopologyData,
    selectNode,
    selectMultipleNodes,
    clearSelection,
    updateFilters,
    switchViewMode,
    updateLayout,
    getNodeById,
    getConnectedNodes,
    highlightPath,
    findShortestPath
  };
});
```

#### 6.3.2 分析状态管理

```javascript
// stores/analysis.js
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import { analysisAPI } from '@/services/analysis';

export const useAnalysisStore = defineStore('analysis', () => {
  // 状态
  const pathAnalysisResults = ref([]);
  const failureAnalysisResults = ref(null);
  const analysisHistory = ref([]);
  const currentAnalysis = ref(null);
  const loading = ref(false);
  const error = ref(null);

  // 计算属性
  const hasResults = computed(() => {
    return pathAnalysisResults.value.length > 0 || failureAnalysisResults.value !== null;
  });

  const analysisStatistics = computed(() => {
    return {
      totalAnalyses: analysisHistory.value.length,
      pathAnalyses: analysisHistory.value.filter(a => a.type === 'path').length,
      failureAnalyses: analysisHistory.value.filter(a => a.type === 'failure').length,
      averageExecutionTime: analysisHistory.value.reduce((sum, a) => sum + a.executionTime, 0) / analysisHistory.value.length || 0
    };
  });

  // Actions
  const analyzePathBetweenDevices = async (sourceId, targetId, analysisType = 'shortest') => {
    loading.value = true;
    error.value = null;

    try {
      const startTime = performance.now();

      const response = await analysisAPI.analyzePath({
        source_device_id: sourceId,
        target_device_id: targetId,
        analysis_type: analysisType
      });

      if (response.success) {
        pathAnalysisResults.value = response.data.paths;

        // 记录分析历史
        const analysis = {
          id: Date.now().toString(),
          type: 'path',
          sourceId,
          targetId,
          analysisType,
          results: response.data,
          timestamp: new Date(),
          executionTime: performance.now() - startTime
        };

        analysisHistory.value.unshift(analysis);
        currentAnalysis.value = analysis;

        // 保持最近50条记录
        if (analysisHistory.value.length > 50) {
          analysisHistory.value = analysisHistory.value.slice(0, 50);
        }
      } else {
        throw new Error(response.message || '路径分析失败');
      }
    } catch (err) {
      error.value = err.message;
      console.error('Path analysis failed:', err);
    } finally {
      loading.value = false;
    }
  };

  const analyzeFailureImpact = async (deviceId, failureType = 'complete') => {
    loading.value = true;
    error.value = null;

    try {
      const startTime = performance.now();

      const response = await analysisAPI.analyzeFailure({
        failed_device_id: deviceId,
        failure_type: failureType
      });

      if (response.success) {
        failureAnalysisResults.value = response.data;

        // 记录分析历史
        const analysis = {
          id: Date.now().toString(),
          type: 'failure',
          deviceId,
          failureType,
          results: response.data,
          timestamp: new Date(),
          executionTime: performance.now() - startTime
        };

        analysisHistory.value.unshift(analysis);
        currentAnalysis.value = analysis;
      } else {
        throw new Error(response.message || '故障影响分析失败');
      }
    } catch (err) {
      error.value = err.message;
      console.error('Failure analysis failed:', err);
    } finally {
      loading.value = false;
    }
  };

  const clearResults = () => {
    pathAnalysisResults.value = [];
    failureAnalysisResults.value = null;
    currentAnalysis.value = null;
    error.value = null;
  };

  const getAnalysisById = (id) => {
    return analysisHistory.value.find(analysis => analysis.id === id);
  };

  const deleteAnalysis = (id) => {
    const index = analysisHistory.value.findIndex(analysis => analysis.id === id);
    if (index > -1) {
      analysisHistory.value.splice(index, 1);
    }
  };

  const exportAnalysisResults = (format = 'json') => {
    if (!currentAnalysis.value) return null;

    const data = {
      analysis: currentAnalysis.value,
      exportTime: new Date().toISOString(),
      format
    };

    if (format === 'json') {
      return JSON.stringify(data, null, 2);
    } else if (format === 'csv') {
      // CSV导出逻辑
      return convertToCSV(data);
    }

    return data;
  };

  return {
    // State
    pathAnalysisResults,
    failureAnalysisResults,
    analysisHistory,
    currentAnalysis,
    loading,
    error,

    // Computed
    hasResults,
    analysisStatistics,

    // Actions
    analyzePathBetweenDevices,
    analyzeFailureImpact,
    clearResults,
    getAnalysisById,
    deleteAnalysis,
    exportAnalysisResults
  };
});
```

#### 6.3.3 UI状态管理

```javascript
// stores/ui.js
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';

export const useUIStore = defineStore('ui', () => {
  // 状态
  const sidebarCollapsed = ref(false);
  const activePanel = ref('topology'); // 'topology' | 'analysis' | 'settings'
  const theme = ref('light'); // 'light' | 'dark'
  const language = ref('zh-CN');
  const notifications = ref([]);
  const modals = ref({
    deviceDetail: { visible: false, deviceId: null },
    pathAnalysis: { visible: false, sourceId: null, targetId: null },
    failureAnalysis: { visible: false, deviceId: null },
    settings: { visible: false }
  });
  const loading = ref({
    global: false,
    topology: false,
    analysis: false
  });

  // 计算属性
  const isDarkTheme = computed(() => theme.value === 'dark');
  const hasNotifications = computed(() => notifications.value.length > 0);
  const unreadNotifications = computed(() => 
    notifications.value.filter(n => !n.read).length
  );

  // Actions
  const toggleSidebar = () => {
    sidebarCollapsed.value = !sidebarCollapsed.value;
  };

  const setActivePanel = (panel) => {
    activePanel.value = panel;
  };

  const toggleTheme = () => {
    theme.value = theme.value === 'light' ? 'dark' : 'light';
    // 应用主题到DOM
    document.documentElement.setAttribute('data-theme', theme.value);
    // 保存到localStorage
    localStorage.setItem('theme', theme.value);
  };

  const setLanguage = (lang) => {
    language.value = lang;
    localStorage.setItem('language', lang);
  };

  const showModal = (modalName, options = {}) => {
    if (modals.value[modalName]) {
      modals.value[modalName] = { ...modals.value[modalName], visible: true, ...options };
    }
  };

  const hideModal = (modalName) => {
    if (modals.value[modalName]) {
      modals.value[modalName].visible = false;
    }
  };

  const addNotification = (notification) => {
    const id = Date.now().toString();
    notifications.value.unshift({
      id,
      read: false,
      timestamp: new Date(),
      ...notification
    });

    // 自动清理旧通知
    if (notifications.value.length > 100) {
      notifications.value = notifications.value.slice(0, 100);
    }

    // 自动消失（如果设置了duration）
    if (notification.duration) {
      setTimeout(() => {
        removeNotification(id);
      }, notification.duration);
    }
  };

  const removeNotification = (id) => {
    const index = notifications.value.findIndex(n => n.id === id);
    if (index > -1) {
      notifications.value.splice(index, 1);
    }
  };

  const markNotificationAsRead = (id) => {
    const notification = notifications.value.find(n => n.id === id);
    if (notification) {
      notification.read = true;
    }
  };

  const markAllNotificationsAsRead = () => {
    notifications.value.forEach(n => n.read = true);
  };

  const setLoading = (key, value) => {
    if (loading.value.hasOwnProperty(key)) {
      loading.value[key] = value;
    }
  };

  // 初始化
  const initializeUI = () => {
    // 从localStorage恢复设置
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme) {
      theme.value = savedTheme;
      document.documentElement.setAttribute('data-theme', savedTheme);
    }

    const savedLanguage = localStorage.getItem('language');
    if (savedLanguage) {
      language.value = savedLanguage;
    }

    const savedSidebarState = localStorage.getItem('sidebarCollapsed');
    if (savedSidebarState !== null) {
      sidebarCollapsed.value = JSON.parse(savedSidebarState);
    }
  };

  return {
    // State
    sidebarCollapsed,
    activePanel,
    theme,
    language,
    notifications,
    modals,
    loading,

    // Computed
    isDarkTheme,
    hasNotifications,
    unreadNotifications,

    // Actions
    toggleSidebar,
    setActivePanel,
    toggleTheme,
    setLanguage,
    showModal,
    hideModal,
    addNotification,
    removeNotification,
    markNotificationAsRead,
    markAllNotificationsAsRead,
    setLoading,
    initializeUI
  };
});
```

#### 6.3.4 组件间通信方案

```javascript
// composables/useTopologyInteraction.js
import { useTopologyStore } from '@/stores/topology';
import { useAnalysisStore } from '@/stores/analysis';
import { useUIStore } from '@/stores/ui';
import { watch, nextTick } from 'vue';

export function useTopologyInteraction() {
  const topologyStore = useTopologyStore();
  const analysisStore = useAnalysisStore();
  const uiStore = useUIStore();

  // 节点选择处理
  const handleNodeSelect = async (nodeId, event) => {
    if (event.ctrlKey || event.metaKey) {
      // 多选模式
      topologyStore.selectNode(nodeId);
    } else {
      // 单选模式
      topologyStore.clearSelection();
      topologyStore.selectNode(nodeId);
    }

    // 显示节点详情
    if (topologyStore.selectedNodes.length === 1) {
      uiStore.showModal('deviceDetail', { deviceId: nodeId });
    }
  };

  // 节点双击处理
  const handleNodeDoubleClick = async (nodeId) => {
    const node = topologyStore.getNodeById(nodeId);
    if (node) {
      // 聚焦到节点
      await nextTick();
      // 触发网络视图聚焦
      window.dispatchEvent(new CustomEvent('focusNode', { detail: { nodeId } }));
    }
  };

  // 边选择处理
  const handleEdgeSelect = (edgeId) => {
    // 实现边选择逻辑
    console.log('Edge selected:', edgeId);
  };

  // 右键菜单处理
  const handleContextMenu = (event, nodeId) => {
    event.preventDefault();

    const contextMenuItems = [
      {
        label: '查看详情',
        action: () => uiStore.showModal('deviceDetail', { deviceId: nodeId })
      },
      {
        label: '路径分析',
        action: () => {
          if (topologyStore.selectedNodes.length === 2) {
            const [source, target] = topologyStore.selectedNodes;
            uiStore.showModal('pathAnalysis', { sourceId: source, targetId: target });
          } else {
            uiStore.addNotification({
              type: 'warning',
              title: '路径分析',
              message: '请选择两个设备进行路径分析',
              duration: 3000
            });
          }
        }
      },
      {
        label: '故障分析',
        action: () => uiStore.showModal('failureAnalysis', { deviceId: nodeId })
      },
      {
        label: '查找连接',
        action: () => {
          const connectedNodes = topologyStore.getConnectedNodes(nodeId);
          topologyStore.selectMultipleNodes(connectedNodes.map(n => n.id));
        }
      }
    ];

    // 显示上下文菜单
    window.dispatchEvent(new CustomEvent('showContextMenu', {
      detail: {
        x: event.clientX,
        y: event.clientY,
        items: contextMenuItems
      }
    }));
  };

  // 监听选择变化
  watch(
    () => topologyStore.selectedNodes,
    (newSelection) => {
      // 更新UI状态
      if (newSelection.length === 0) {
        uiStore.hideModal('deviceDetail');
      }

      // 触发选择变化事件
      window.dispatchEvent(new CustomEvent('selectionChanged', {
        detail: { selectedNodes: newSelection }
      }));
    },
    { deep: true }
  );

  // 监听分析结果变化
  watch(
    () => analysisStore.currentAnalysis,
    (newAnalysis) => {
      if (newAnalysis) {
        // 显示分析结果通知
        uiStore.addNotification({
          type: 'success',
          title: '分析完成',
          message: `${newAnalysis.type === 'path' ? '路径' : '故障'}分析已完成`,
          duration: 5000
        });

        // 切换到分析面板
        uiStore.setActivePanel('analysis');
      }
    }
  );

  return {
    handleNodeSelect,
    handleNodeDoubleClick,
    handleEdgeSelect,
    handleContextMenu
  };
}
      filteredNodes: filteredNodes.value.length,
      selectedNodes: selectedNodes.value.length,
      deviceTypes: [...new Set(nodes.value.map(n => n.type))],
      locations: [...new Set(nodes.value.map(n => n.station))]
    };
  });

  // 操作方法
  const fetchTopologyData = async (params = {}) => {
    loading.value = true;
    error.value = null;

    try {
      const response = await topologyAPI.getDeviceTopology({
        ...filters.value,
        ...params
      });

      if (response.success) {
        nodes.value = response.data.topology.nodes;
        edges.value = response.data.topology.edges;
      } else {
        throw new Error(response.message);
      }
    } catch (err) {
      error.value = err.message;
      console.error('获取拓扑数据失败:', err);
    } finally {
      loading.value = false;
    }
  };

  const updateNodePositions = async (positions) => {
    try {
      const response = await topologyAPI.updateDevicePositions({ positions });
      if (!response.success) {
        throw new Error(response.message);
      }
      return response;
    } catch (err) {
      error.value = err.message;
      throw err;
    }
  };

  const setSelection = (nodeIds = [], edgeIds = []) => {
    selectedNodes.value = nodeIds;
    selectedEdges.value = edgeIds;
  };

  const updateFilters = (newFilters) => {
    filters.value = { ...filters.value, ...newFilters };
  };

  const setViewMode = (mode) => {
    viewMode.value = mode;
    if (mode === 'port') {
      fetchPortTopologyData();
    } else {
      fetchTopologyData();
    }
  };

  const resetView = () => {
    selectedNodes.value = [];
    selectedEdges.value = [];
    filters.value = {
      location: '',
      deviceType: '',
      includeOffline: true
    };
  };

  return {
    // 状态
    nodes,
    edges,
    selectedNodes,
    selectedEdges,
    viewMode,
    layoutType,
    filters,
    loading,
    error,

    // 计算属性
    filteredNodes,
    networkData,
    statistics,

    // 方法
    fetchTopologyData,
    updateNodePositions,
    setSelection,
    updateFilters,
    setViewMode,
    resetView
  };
});
```

### 6.4 移动端适配

#### 6.4.1 响应式设计

```css
/* 移动端适配样式 */
@media (max-width: 768px) {
  .topology-container {
    flex-direction: column;
  }

  .topology-controls {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 1000;
    background: white;
    border-top: 1px solid #e4e7ed;
    padding: 8px;
  }

  .topology-canvas {
    height: calc(100vh - 120px);
  }

  .node-info-panel {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 2000;
    background: white;
    transform: translateY(100%);
    transition: transform 0.3s ease;
  }

  .node-info-panel.active {
    transform: translateY(0);
  }
}

@media (max-width: 480px) {
  .vis-network {
    touch-action: pan-x pan-y;
  }

  .topology-legend {
    display: none;
  }

  .topology-controls .el-button {
    padding: 8px 12px;
    font-size: 12px;
  }
}
```

#### 6.4.2 触摸交互优化

```javascript
// 移动端触摸事件处理
export const setupMobileInteraction = (network) => {
  let touchStartTime = 0;
  let touchStartPos = { x: 0, y: 0 };

  // 长按检测
  const handleTouchStart = (event) => {
    touchStartTime = Date.now();
    touchStartPos = {
      x: event.touches[0].clientX,
      y: event.touches[0].clientY
    };
  };

  const handleTouchEnd = (event) => {
    const touchEndTime = Date.now();
    const touchDuration = touchEndTime - touchStartTime;

    // 长按事件（超过500ms）
    if (touchDuration > 500) {
      const params = network.getEventProperties(event);
      if (params.nodes.length > 0) {
        // 触发右键菜单
        showContextMenu(params);
      }
    }
  };

  // 双击缩放
  let lastTap = 0;
  const handleDoubleTap = (event) => {
    const currentTime = new Date().getTime();
    const tapLength = currentTime - lastTap;

    if (tapLength < 500 && tapLength > 0) {
      const params = network.getEventProperties(event);
      if (params.nodes.length > 0) {
        // 聚焦到节点
        network.focus(params.nodes[0], {
          scale: 1.5,
          animation: { duration: 1000 }
        });
      }
      event.preventDefault();
    }
    lastTap = currentTime;
  };

  // 手势缩放
  let initialDistance = 0;
  let initialScale = 1;

  const getDistance = (touches) => {
    const dx = touches[0].clientX - touches[1].clientX;
    const dy = touches[0].clientY - touches[1].clientY;
    return Math.sqrt(dx * dx + dy * dy);
  };

  const handleTouchMove = (event) => {
    if (event.touches.length === 2) {
      event.preventDefault();

      const currentDistance = getDistance(event.touches);

      if (initialDistance === 0) {
        initialDistance = currentDistance;
        initialScale = network.getScale();
      } else {
        const scale = (currentDistance / initialDistance) * initialScale;
        network.moveTo({ scale: Math.max(0.1, Math.min(3, scale)) });
      }
    }
  };

  const handleTouchEndGesture = () => {
    initialDistance = 0;
  };

  // 绑定事件
  const canvas = network.getCanvas();
  canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
  canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
  canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
  canvas.addEventListener('touchend', handleTouchEndGesture, { passive: false });

  // 双击事件
  canvas.addEventListener('touchend', handleDoubleTap, { passive: false });

  return {
    destroy: () => {
      canvas.removeEventListener('touchstart', handleTouchStart);
      canvas.removeEventListener('touchend', handleTouchEnd);
      canvas.removeEventListener('touchmove', handleTouchMove);
      canvas.removeEventListener('touchend', handleTouchEndGesture);
      canvas.removeEventListener('touchend', handleDoubleTap);
    }
  };
};
```

#### 6.4.3 移动端组件适配

```vue
<!-- MobileTopologyView.vue -->
<template>
  <div class="mobile-topology-view">
    <!-- 顶部工具栏 -->
    <div class="mobile-toolbar">
      <el-button-group size="small">
        <el-button 
          :type="viewMode === 'device' ? 'primary' : 'default'"
          @click="switchViewMode('device')"
        >
          设备视图
        </el-button>
        <el-button 
          :type="viewMode === 'port' ? 'primary' : 'default'"
          @click="switchViewMode('port')"
        >
          端口视图
        </el-button>
      </el-button-group>

      <el-button 
        size="small" 
        icon="el-icon-search" 
        @click="showSearchPanel = true"
      >
        搜索
      </el-button>
    </div>

    <!-- 拓扑图容器 -->
    <div 
      ref="networkContainer" 
      class="mobile-network-container"
      :class="{ 'fullscreen': isFullscreen }"
    >
      <!-- 网络图 -->
    </div>

    <!-- 底部控制栏 -->
    <div class="mobile-controls">
      <el-button-group size="small">
        <el-button icon="el-icon-zoom-in" @click="zoomIn" />
        <el-button icon="el-icon-zoom-out" @click="zoomOut" />
        <el-button icon="el-icon-refresh" @click="resetView" />
        <el-button icon="el-icon-full-screen" @click="toggleFullscreen" />
      </el-button-group>

      <el-button 
        size="small" 
        type="primary" 
        @click="showAnalysisPanel = true"
      >
        分析
      </el-button>
    </div>

    <!-- 搜索面板 -->
    <el-drawer
      v-model="showSearchPanel"
      title="设备搜索"
      direction="ttb"
      size="60%"
    >
      <MobileSearchPanel @select-device="handleDeviceSelect" />
    </el-drawer>

    <!-- 分析面板 -->
    <el-drawer
      v-model="showAnalysisPanel"
      title="拓扑分析"
      direction="btt"
      size="80%"
    >
      <MobileAnalysisPanel />
    </el-drawer>

    <!-- 设备详情面板 -->
    <el-drawer
      v-model="showDeviceDetail"
      :title="selectedDevice?.name || '设备详情'"
      direction="rtl"
      size="100%"
    >
      <MobileDeviceDetail :device="selectedDevice" />
    </el-drawer>

    <!-- 浮动操作按钮 -->
    <div class="mobile-fab">
      <el-button 
        type="primary" 
        circle 
        icon="el-icon-plus"
        @click="showQuickActions = !showQuickActions"
      />

      <transition name="fab-menu">
        <div v-show="showQuickActions" class="fab-menu">
          <el-button 
            circle 
            icon="el-icon-location"
            @click="centerView"
            title="居中视图"
          />
          <el-button 
            circle 
            icon="el-icon-connection"
            @click="showConnectionPanel = true"
            title="连接分析"
          />
          <el-button 
            circle 
            icon="el-icon-warning"
            @click="showAlarmPanel = true"
            title="告警信息"
          />
        </div>
      </transition>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue';
import { useTopologyStore } from '@/stores/topology';
import { useUIStore } from '@/stores/ui';
import { setupMobileInteraction } from '@/utils/mobile-interaction';

const topologyStore = useTopologyStore();
const uiStore = useUIStore();

const networkContainer = ref(null);
const showSearchPanel = ref(false);
const showAnalysisPanel = ref(false);
const showDeviceDetail = ref(false);
const showQuickActions = ref(false);
const isFullscreen = ref(false);
const selectedDevice = ref(null);

let network = null;
let mobileInteraction = null;

// 视图模式切换
const switchViewMode = async (mode) => {
  await topologyStore.switchViewMode(mode);
  updateNetwork();
};

// 缩放控制
const zoomIn = () => {
  const scale = network.getScale() * 1.2;
  network.moveTo({ scale: Math.min(scale, 3) });
};

const zoomOut = () => {
  const scale = network.getScale() * 0.8;
  network.moveTo({ scale: Math.max(scale, 0.1) });
};

const resetView = () => {
  network.fit({
    animation: { duration: 1000 }
  });
};

const centerView = () => {
  network.moveTo({
    position: { x: 0, y: 0 },
    scale: 1,
    animation: { duration: 800 }
  });
};

// 全屏切换
const toggleFullscreen = () => {
  if (!document.fullscreenElement) {
    networkContainer.value.requestFullscreen();
    isFullscreen.value = true;
  } else {
    document.exitFullscreen();
    isFullscreen.value = false;
  }
};

// 设备选择处理
const handleDeviceSelect = (device) => {
  selectedDevice.value = device;
  showDeviceDetail.value = true;
  showSearchPanel.value = false;

  // 聚焦到设备
  if (network && device.id) {
    network.focus(device.id, {
      scale: 1.5,
      animation: { duration: 1000 }
    });
  }
};

// 网络更新
const updateNetwork = () => {
  if (network) {
    const data = topologyStore.networkData;
    network.setData(data);
  }
};

// 初始化网络
const initNetwork = () => {
  const options = {
    nodes: {
      shape: 'dot',
      size: 20,
      font: {
        size: 12,
        color: '#333'
      },
      borderWidth: 2,
      shadow: true
    },
    edges: {
      width: 2,
      color: { inherit: 'from' },
      smooth: {
        type: 'continuous',
        roundness: 0.5
      }
    },
    physics: {
      enabled: true,
      stabilization: { iterations: 100 }
    },
    interaction: {
      dragNodes: true,
      dragView: true,
      zoomView: true,
      selectConnectedEdges: false,
      hover: true,
      hoverConnectedEdges: false,
      keyboard: false
    },
    layout: {
      improvedLayout: true
    }
  };

  network = new vis.Network(networkContainer.value, topologyStore.networkData, options);

  // 设置移动端交互
  mobileInteraction = setupMobileInteraction(network);

  // 绑定事件
  network.on('click', (params) => {
    if (params.nodes.length > 0) {
      const nodeId = params.nodes[0];
      const device = topologyStore.getNodeById(nodeId);
      handleDeviceSelect(device);
    }
  });

  network.on('doubleClick', (params) => {
    if (params.nodes.length > 0) {
      const nodeId = params.nodes[0];
      network.focus(nodeId, {
        scale: 2,
        animation: { duration: 1000 }
      });
    }
  });
};

// 响应式处理
const handleResize = () => {
  if (network) {
    network.redraw();
    network.fit();
  }
};

onMounted(() => {
  initNetwork();
  window.addEventListener('resize', handleResize);
  window.addEventListener('orientationchange', handleResize);
});

onUnmounted(() => {
  if (mobileInteraction) {
    mobileInteraction.destroy();
  }
  window.removeEventListener('resize', handleResize);
  window.removeEventListener('orientationchange', handleResize);
});
</script>

<style scoped>
.mobile-topology-view {
  height: 100vh;
  display: flex;
  flex-direction: column;
  background: #f5f5f5;
}

.mobile-toolbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 16px;
  background: white;
  border-bottom: 1px solid #e4e7ed;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.mobile-network-container {
  flex: 1;
  position: relative;
  overflow: hidden;
}

.mobile-network-container.fullscreen {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 9999;
}

.mobile-controls {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 16px;
  background: white;
  border-top: 1px solid #e4e7ed;
  box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.1);
}

.mobile-fab {
  position: fixed;
  bottom: 80px;
  right: 16px;
  z-index: 1000;
}

.fab-menu {
  position: absolute;
  bottom: 60px;
  right: 0;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.fab-menu-enter-active,
.fab-menu-leave-active {
  transition: all 0.3s ease;
}

.fab-menu-enter-from,
.fab-menu-leave-to {
  opacity: 0;
  transform: translateY(20px);
}

/* 移动端抽屉样式优化 */
:deep(.el-drawer) {
  border-radius: 16px 16px 0 0;
}

:deep(.el-drawer__header) {
  padding: 16px;
  border-bottom: 1px solid #e4e7ed;
}

:deep(.el-drawer__body) {
  padding: 16px;
}

/* 触摸优化 */
.mobile-topology-view * {
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
}

/* 横屏适配 */
@media screen and (orientation: landscape) {
  .mobile-toolbar {
    padding: 4px 16px;
  }

  .mobile-controls {
    padding: 4px 16px;
  }

  .mobile-fab {
    bottom: 60px;
  }
}

/* 小屏幕优化 */
@media (max-width: 360px) {
  .mobile-toolbar {
    padding: 6px 12px;
  }

  .mobile-controls {
    padding: 6px 12px;
  }

  .mobile-fab {
    right: 12px;
    bottom: 70px;
  }
}
</style>
```

#### 6.4.4 移动端性能优化

```javascript
// utils/mobile-performance.js
export class MobilePerformanceOptimizer {
  constructor(network) {
    this.network = network;
    this.isLowEndDevice = this.detectLowEndDevice();
    this.setupOptimizations();
  }

  // 检测低端设备
  detectLowEndDevice() {
    const memory = navigator.deviceMemory || 4;
    const cores = navigator.hardwareConcurrency || 4;
    const connection = navigator.connection;

    // 内存小于2GB或CPU核心数少于4个认为是低端设备
    if (memory < 2 || cores < 4) {
      return true;
    }

    // 网络连接较慢
    if (connection && (connection.effectiveType === '2g' || connection.effectiveType === 'slow-2g')) {
      return true;
    }

    return false;
  }

  // 设置优化策略
  setupOptimizations() {
    if (this.isLowEndDevice) {
      this.applyLowEndOptimizations();
    } else {
      this.applyStandardOptimizations();
    }
  }

  // 低端设备优化
  applyLowEndOptimizations() {
    const options = {
      physics: {
        enabled: false // 禁用物理引擎
      },
      nodes: {
        shadow: false, // 禁用阴影
        smooth: false  // 禁用平滑
      },
      edges: {
        smooth: false,
        shadow: false
      },
      interaction: {
        hover: false,  // 禁用悬停效果
        tooltipDelay: 1000
      }
    };

    this.network.setOptions(options);
  }

  // 标准优化
  applyStandardOptimizations() {
    const options = {
      physics: {
        enabled: true,
        stabilization: {
          iterations: 50 // 减少稳定化迭代次数
        }
      },
      nodes: {
        shadow: {
          enabled: true,
          size: 5
        }
      },
      edges: {
        smooth: {
          type: 'continuous',
          roundness: 0.3
        }
      }
    };

    this.network.setOptions(options);
  }

  // 动态调整节点数量
  optimizeNodeCount(nodes, maxNodes = 100) {
    if (nodes.length <= maxNodes) {
      return nodes;
    }

    // 按重要性排序，保留最重要的节点
    return nodes
      .sort((a, b) => (b.importance || 0) - (a.importance || 0))
      .slice(0, maxNodes);
  }

  // 延迟加载
  setupLazyLoading() {
    let loadTimeout;

    this.network.on('zoom', () => {
      clearTimeout(loadTimeout);
      loadTimeout = setTimeout(() => {
        this.loadVisibleNodes();
      }, 300);
    });

    this.network.on('dragEnd', () => {
      clearTimeout(loadTimeout);
      loadTimeout = setTimeout(() => {
        this.loadVisibleNodes();
      }, 300);
    });
  }

  // 加载可见节点
  loadVisibleNodes() {
    const viewPosition = this.network.getViewPosition();
    const scale = this.network.getScale();

    // 计算可见区域
    const canvas = this.network.getCanvas();
    const canvasRect = canvas.getBoundingClientRect();

    const visibleArea = {
      left: viewPosition.x - (canvasRect.width / scale) / 2,
      right: viewPosition.x + (canvasRect.width / scale) / 2,
      top: viewPosition.y - (canvasRect.height / scale) / 2,
      bottom: viewPosition.y + (canvasRect.height / scale) / 2
    };

    // 只显示可见区域内的节点
    this.updateVisibleNodes(visibleArea);
  }

  // 更新可见节点
  updateVisibleNodes(visibleArea) {
    // 实现节点可见性更新逻辑
    console.log('Updating visible nodes for area:', visibleArea);
  }

  // 内存清理
  cleanup() {
    // 清理不必要的数据和事件监听器
    this.network.off('zoom');
    this.network.off('dragEnd');
  }
}
```

#### 6.4.5 移动端手势库集成

```javascript
// utils/mobile-gestures.js
import Hammer from 'hammerjs';

export class MobileGestureHandler {
  constructor(element, network) {
    this.element = element;
    this.network = network;
    this.hammer = new Hammer(element);
    this.setupGestures();
  }

  setupGestures() {
    // 启用捏合手势
    this.hammer.get('pinch').set({ enable: true });
    this.hammer.get('pan').set({ direction: Hammer.DIRECTION_ALL });

    let initialScale = 1;
    let initialPosition = { x: 0, y: 0 };

    // 捏合缩放
    this.hammer.on('pinchstart', (event) => {
      initialScale = this.network.getScale();
    });

    this.hammer.on('pinchmove', (event) => {
      const scale = initialScale * event.scale;
      this.network.moveTo({
        scale: Math.max(0.1, Math.min(3, scale))
      });
    });

    // 平移
    this.hammer.on('panstart', (event) => {
      initialPosition = this.network.getViewPosition();
    });

    this.hammer.on('panmove', (event) => {
      const scale = this.network.getScale();
      const position = {
        x: initialPosition.x - event.deltaX / scale,
        y: initialPosition.y - event.deltaY / scale
      };

      this.network.moveTo({ position });
    });

    // 双击缩放
    this.hammer.on('doubletap', (event) => {
      const currentScale = this.network.getScale();
      const newScale = currentScale < 1.5 ? 2 : 1;

      this.network.moveTo({
        scale: newScale,
        animation: { duration: 300 }
      });
    });

    // 长按显示菜单
    this.hammer.on('press', (event) => {
      const params = this.network.getEventProperties(event.srcEvent);
      if (params.nodes.length > 0) {
        this.showContextMenu(event, params);
      }
    });
  }

  showContextMenu(event, params) {
    // 显示上下文菜单
    const menu = document.createElement('div');
    menu.className = 'mobile-context-menu';
    menu.innerHTML = `
      <div class="menu-item" data-action="detail">查看详情</div>
      <div class="menu-item" data-action="analyze">路径分析</div>
      <div class="menu-item" data-action="highlight">高亮连接</div>
    `;

    menu.style.position = 'fixed';
    menu.style.left = event.center.x + 'px';
    menu.style.top = event.center.y + 'px';
    menu.style.zIndex = '9999';

    document.body.appendChild(menu);

    // 点击菜单项处理
    menu.addEventListener('click', (e) => {
      const action = e.target.dataset.action;
      this.handleMenuAction(action, params);
      document.body.removeChild(menu);
    });

    // 点击其他地方关闭菜单
    setTimeout(() => {
      const closeMenu = () => {
        if (document.body.contains(menu)) {
          document.body.removeChild(menu);
        }
        document.removeEventListener('click', closeMenu);
      };
      document.addEventListener('click', closeMenu);
    }, 100);
  }

  handleMenuAction(action, params) {
    const nodeId = params.nodes[0];

    switch (action) {
      case 'detail':
        // 显示设备详情
        this.showDeviceDetail(nodeId);
        break;
      case 'analyze':
        // 开始路径分析
        this.startPathAnalysis(nodeId);
        break;
      case 'highlight':
        // 高亮连接
        this.highlightConnections(nodeId);
        break;
    }
  }

  destroy() {
    this.hammer.destroy();
  }
}
```

      } else {
        // 适应视图
        network.fit({ animation: { duration: 1000 } });
      }
      event.preventDefault();
    }
    
    lastTap = currentTime;

  };

  // 绑定事件
  const canvas = network.canvas.frame.canvas;
  canvas.addEventListener('touchstart', handleTouchStart);
  canvas.addEventListener('touchend', handleTouchEnd);
  canvas.addEventListener('touchend', handleDoubleTap);
};

```
### 6.5 测试和部署配置

#### 6.5.1 单元测试配置

```javascript
// vitest.config.js
import { defineConfig } from 'vitest/config';
import vue from '@vitejs/plugin-vue';

export default defineConfig({
  plugins: [vue()],
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: ['./src/test/setup.js']
  },
  resolve: {
    alias: {
      '@': '/src'
    }
  }
});
```

```javascript
// src/test/setup.js
import { config } from '@vue/test-utils';
import ElementPlus from 'element-plus';

config.global.plugins = [ElementPlus];
```

#### 6.5.2 E2E测试配置

```javascript
// cypress.config.js
import { defineConfig } from 'cypress';

export default defineConfig({
  e2e: {
    baseUrl: 'http://localhost:5173',
    supportFile: 'cypress/support/e2e.js',
    specPattern: 'cypress/e2e/**/*.cy.{js,jsx,ts,tsx}',
    viewportWidth: 1280,
    viewportHeight: 720
  },
  component: {
    devServer: {
      framework: 'vue',
      bundler: 'vite'
    }
  }
});
```

### 5.3 核心算法设计

#### 5.3.1 拓扑构建算法

```python
def build_unified_topology(devices, connections, view_type='device'):
    """
    构建统一拓扑图数据结构

    Args:
        devices: 设备列表
        connections: 连接列表
        view_type: 视图类型 ('device' | 'port')

    Returns:
        拓扑图数据结构
    """
    if view_type == 'device':
        return build_device_topology(devices, connections)
    elif view_type == 'port':
        return build_port_topology(devices, connections)
    else:
        raise ValueError(f"Unsupported view type: {view_type}")

def extract_device_properties(device):
    """
    提取设备属性信息

    Args:
        device: 设备对象

    Returns:
        dict: 设备属性字典
    """
    properties = {
        'asset_id': getattr(device, 'asset_id', ''),
        'model': getattr(device, 'model', ''),
        'location': getattr(device, 'location', ''),
        'power_rating': getattr(device, 'power_rating', 0),
        'vendor': getattr(device, 'vendor', ''),
        'commission_date': getattr(device, 'commission_date', None),
        'room_name': getattr(device, 'room_name', ''),
        'system_name': getattr(device, 'system_name', ''),
        'room_level': getattr(device, 'room_level', ''),
        'resource_room_name': getattr(device, 'resource_room_name', ''),
        'resource_room_code': getattr(device, 'resource_room_code', '')
    }

    # 格式化日期
    if properties['commission_date']:
        properties['commission_date'] = properties['commission_date'].strftime('%Y-%m-%d')

    # 移除空值
    return {k: v for k, v in properties.items() if v is not None and v != ''}

def aggregate_connections(connections):
    """
    聚合设备间的连接关系

    Args:
        connections: 连接列表

    Returns:
        list: 聚合后的边列表
    """
    # 按设备对分组连接
    device_pairs = {}

    for conn in connections:
        # 确定设备对的键（保证一致性）
        device_a = conn.source_device_id
        device_b = conn.target_device_id
        pair_key = tuple(sorted([device_a, device_b]))

        if pair_key not in device_pairs:
            device_pairs[pair_key] = []
        device_pairs[pair_key].append(conn)

    # 为每个设备对创建一条聚合边
    aggregated_edges = []

    for pair_key, pair_connections in device_pairs.items():
        device_a, device_b = pair_key

        # 选择主连接（优先级：电缆 > 母线 > 其他）
        primary_conn = select_primary_connection(pair_connections)

        # 计算聚合属性
        total_capacity = sum(getattr(conn, 'rated_current', 0) for conn in pair_connections)
        connection_count = len(pair_connections)

        edge = {
            'id': f"edge_{device_a}_{device_b}",
            'from': device_a,
            'to': device_b,
            'type': primary_conn.connection_type,
            'connection_count': connection_count,
            'total_capacity': total_capacity,
            'hierarchy_relation': primary_conn.hierarchy_relation,
            'upstream_downstream': primary_conn.upstream_downstream,
            'properties': {
                'primary_connection_id': primary_conn.id,
                'cable_model': primary_conn.cable_model,
                'cable_length': primary_conn.cable_length,
                'rated_voltage': primary_conn.rated_voltage,
                'connection_ids': [conn.id for conn in pair_connections]
            }
        }

        aggregated_edges.append(edge)

    return aggregated_edges

def select_primary_connection(connections):
    """
    从多个连接中选择主连接

    Args:
        connections: 连接列表

    Returns:
        Connection: 主连接对象
    """
    # 连接类型优先级
    type_priority = {
        'cable': 1,
        'busbar': 2,
        'busway': 3,
        'other': 4
    }

    # 按优先级和额定电流排序
    sorted_connections = sorted(
        connections,
        key=lambda conn: (
            type_priority.get(conn.connection_type, 4),
            -(getattr(conn, 'rated_current', 0) or 0)
        )
    )

    return sorted_connections[0]

def build_device_topology(devices, connections):
    """
    构建设备级拓扑图
    """
    # 创建设备节点
    nodes = []
    for device in devices:
        node = {
            'id': device.device_id,
            'label': device.device_name,
            'type': device.device_type,
            'status': device.status,
            'properties': extract_device_properties(device)
        }
        nodes.append(node)

    # 创建连接边（聚合处理）
    edges = aggregate_connections(connections)

    return {
        'nodes': nodes,
        'edges': edges,
        'metadata': {
            'view_type': 'device',
            'node_count': len(nodes),
            'edge_count': len(edges)
        }
    }

def build_port_topology(devices, connections):
    """
    构建端口级拓扑图
    """
    # 创建设备和端口节点
    nodes = []
    for device in devices:
        # 设备节点
        device_node = {
            'id': device.device_id,
            'label': device.device_name,
            'type': 'device',
            'category': device.device_type
        }
        nodes.append(device_node)

        # 端口节点
        for port in device.ports:
            port_node = {
                'id': port.port_id,
                'label': port.port_name,
                'type': 'port',
                'parent': device.device_id,
                'properties': extract_port_properties(port)
            }
            nodes.append(port_node)

    # 创建连接边
    edges = []
    for conn in connections:
        edge = {
            'id': conn.connection_id,
            'from': conn.from_port_id,
            'to': conn.to_port_id,
            'type': conn.connection_type,
            'properties': extract_connection_properties(conn)
        }
        edges.append(edge)

    return {
        'nodes': nodes,
        'edges': edges,
        'metadata': {
            'view_type': 'port',
            'device_count': len(devices),
            'port_count': sum(len(d.ports) for d in devices),
            'connection_count': len(edges)
        }
    }
```

#### 5.3.2 路径分析算法

```python
import networkx as nx
from typing import List, Dict, Any

def analyze_paths(graph_data: Dict, source_id: str, target_id: str, 
                 analysis_type: str = 'shortest') -> Dict[str, Any]:
    """
    分析设备间的路径

    Args:
        graph_data: 拓扑图数据
        source_id: 源设备ID
        target_id: 目标设备ID
        analysis_type: 分析类型 ('shortest' | 'all' | 'critical')

    Returns:
        路径分析结果
    """
    # 构建NetworkX图
    G = nx.DiGraph()

    # 添加节点
    for node in graph_data['nodes']:
        G.add_node(node['id'], **node.get('properties', {}))

    # 添加边
    for edge in graph_data['edges']:
        weight = calculate_edge_weight(edge)
        G.add_edge(edge['from'], edge['to'], 
                  weight=weight, **edge.get('properties', {}))

    # 路径分析
    if analysis_type == 'shortest':
        paths = find_shortest_paths(G, source_id, target_id)
    elif analysis_type == 'all':
        paths = find_all_paths(G, source_id, target_id)
    elif analysis_type == 'critical':
        paths = find_critical_paths(G, source_id, target_id)
    else:
        raise ValueError(f"Unsupported analysis type: {analysis_type}")

    return {
        'paths': paths,
        'analysis_summary': generate_path_summary(paths),
        'recommendations': generate_path_recommendations(paths)
    }

def find_shortest_paths(G: nx.DiGraph, source: str, target: str) -> List[Dict]:
    """
    查找最短路径
    """
    try:
        path = nx.shortest_path(G, source, target, weight='weight')
        path_length = nx.shortest_path_length(G, source, target, weight='weight')

        return [{
            'path_id': f"shortest_{source}_{target}",
            'nodes': path,
            'edges': get_path_edges(G, path),
            'total_weight': path_length,
            'reliability_score': calculate_path_reliability(G, path)
        }]
    except nx.NetworkXNoPath:
        return []

def find_all_paths(G: nx.DiGraph, source: str, target: str, 
                  max_paths: int = 10) -> List[Dict]:
    """
    查找所有路径
    """
    paths = []
    try:
        all_paths = nx.all_simple_paths(G, source, target)
        for i, path in enumerate(all_paths):
            if i >= max_paths:
                break

            path_weight = calculate_path_weight(G, path)
            paths.append({
                'path_id': f"path_{i}_{source}_{target}",
                'nodes': path,
                'edges': get_path_edges(G, path),
                'total_weight': path_weight,
                'reliability_score': calculate_path_reliability(G, path)
            })
    except nx.NetworkXNoPath:
        pass

    return sorted(paths, key=lambda x: x['total_weight'])
```

#### 5.3.3 故障影响分析算法

```python
def find_affected_nodes(G_original, G_failed, failed_node_id):
    """
    查找受故障影响的节点

    Args:
        G_original: 原始图
        G_failed: 故障后的图
        failed_node_id: 故障节点ID

    Returns:
        list: 受影响的节点列表
    """
    affected_nodes = []

    # 获取所有节点
    all_nodes = list(G_original.nodes())

    # 查找失去连接的节点
    for node in all_nodes:
        if node == failed_node_id:
            continue

        # 检查是否失去与关键节点的连接
        lost_connections = check_lost_connections(G_original, G_failed, node, failed_node_id)

        if lost_connections:
            node_info = {
                'node_id': node,
                'node_type': G_original.nodes[node].get('type', 'unknown'),
                'impact_level': calculate_impact_level(G_original, node, failed_node_id),
                'lost_connections': lost_connections,
                'alternative_paths': find_alternative_paths_for_node(G_failed, node)
            }
            affected_nodes.append(node_info)

    return affected_nodes

def check_lost_connections(G_original, G_failed, node, failed_node):
    """
    检查节点失去的连接
    """
    lost_connections = []

    # 检查直接连接
    if G_original.has_edge(node, failed_node) or G_original.has_edge(failed_node, node):
        lost_connections.append({
            'type': 'direct',
            'target': failed_node,
            'severity': 'high'
        })

    # 检查间接连接（通过故障节点的路径）
    try:
        original_paths = list(nx.all_simple_paths(G_original, node, failed_node, cutoff=3))
        if original_paths:
            for path in original_paths:
                if len(path) > 2:  # 间接路径
                    lost_connections.append({
                        'type': 'indirect',
                        'path': path,
                        'severity': 'medium'
                    })
    except nx.NetworkXNoPath:
        pass

    return lost_connections

def estimate_downtime(failure_type, affected_nodes):
    """
    估算停机时间

    Args:
        failure_type: 故障类型
        affected_nodes: 受影响的节点列表

    Returns:
        dict: 停机时间估算结果
    """
    # 基础修复时间（小时）
    base_repair_times = {
        'complete': 4.0,    # 完全故障
        'partial': 2.0,     # 部分故障
        'maintenance': 1.0  # 维护
    }

    base_time = base_repair_times.get(failure_type, 4.0)

    # 影响因子
    complexity_factor = 1.0
    if len(affected_nodes) > 10:
        complexity_factor = 1.5
    elif len(affected_nodes) > 5:
        complexity_factor = 1.2

    # 关键设备因子
    critical_count = sum(1 for node in affected_nodes 
                        if node.get('impact_level', 'low') == 'high')
    critical_factor = 1.0 + (critical_count * 0.3)

    # 计算总时间
    estimated_hours = base_time * complexity_factor * critical_factor

    return {
        'estimated_hours': round(estimated_hours, 1),
        'min_hours': round(estimated_hours * 0.7, 1),
        'max_hours': round(estimated_hours * 1.5, 1),
        'confidence_level': calculate_confidence_level(failure_type, affected_nodes)
    }

def calculate_impact_level(G, node, failed_node):
    """
    计算节点的影响级别
    """
    node_data = G.nodes[node]

    # 基于设备类型的影响级别
    device_type = node_data.get('type', 'unknown')
    type_impact = {
        'transformer': 'high',
        'switchgear': 'high',
        'ups': 'medium',
        'pdu': 'medium',
        'server': 'low',
        'unknown': 'low'
    }

    base_impact = type_impact.get(device_type, 'low')

    # 基于连接度的调整
    degree = G.degree(node)
    if degree > 5:
        if base_impact == 'low':
            base_impact = 'medium'
        elif base_impact == 'medium':
            base_impact = 'high'

    return base_impact

def calculate_confidence_level(failure_type, affected_nodes):
    """
    计算预估的置信度
    """
    base_confidence = {
        'maintenance': 0.9,
        'partial': 0.7,
        'complete': 0.6
    }

    confidence = base_confidence.get(failure_type, 0.6)

    # 根据影响节点数量调整
    if len(affected_nodes) > 20:
        confidence *= 0.8
    elif len(affected_nodes) < 5:
        confidence *= 1.1

    return min(confidence, 1.0)

def analyze_failure_impact(graph_data: Dict, failed_node_id: str, 
                          failure_type: str = 'complete') -> Dict[str, Any]:
    """
    分析故障影响

    Args:
        graph_data: 拓扑图数据
        failed_node_id: 故障节点ID
        failure_type: 故障类型 ('complete' | 'partial' | 'maintenance')

    Returns:
        故障影响分析结果
    """
    # 构建图
    G = build_networkx_graph(graph_data)

    # 移除故障节点
    G_failed = G.copy()
    if failure_type == 'complete':
        G_failed.remove_node(failed_node_id)
    elif failure_type == 'partial':
        # 部分故障：降低节点权重
        for edge in G_failed.edges(failed_node_id):
            G_failed[edge[0]][edge[1]]['weight'] *= 2

    # 分析影响
    affected_nodes = find_affected_nodes(G, G_failed, failed_node_id)
    critical_paths = find_critical_paths_through_node(G, failed_node_id)
    alternative_paths = find_alternative_paths(G_failed, affected_nodes)

    return {
        'impact_summary': {
            'affected_devices': len(affected_nodes),
            'critical_devices': count_critical_devices(affected_nodes),
            'estimated_downtime': estimate_downtime(failure_type, affected_nodes),
            'risk_level': assess_risk_level(affected_nodes)
        },
        'affected_devices': affected_nodes,
        'critical_paths': critical_paths,
        'alternative_paths': alternative_paths,
        'recommendations': generate_failure_recommendations(
            failed_node_id, failure_type, affected_nodes
        )
    }
```

### 5.4 性能优化策略

#### 5.4.1 前端性能优化

##### 1. 虚拟化渲染实现

```javascript
// 虚拟化拓扑图渲染器
class VirtualizedTopologyRenderer {
  constructor(container, options = {}) {
    this.container = container;
    this.options = {
      threshold: 1000,        // 启用虚拟化的节点阈值
      viewportBuffer: 100,    // 视口缓冲区大小
      chunkSize: 200,         // 批处理大小
      renderDelay: 16,        // 渲染延迟(ms)
      ...options
    };

    this.visibleNodes = new Set();
    this.visibleEdges = new Set();
    this.spatialIndex = null;
    this.renderQueue = [];
    this.isRendering = false;
  }

  /**
   * 初始化虚拟化渲染
   */
  initialize(nodes, edges) {
    this.allNodes = nodes;
    this.allEdges = edges;

    if (nodes.length > this.options.threshold) {
      this.enableVirtualization();
    } else {
      this.renderAll();
    }
  }

  /**
   * 启用虚拟化渲染
   */
  enableVirtualization() {
    // 创建空间索引用于快速查找
    this.spatialIndex = this.createSpatialIndex(this.allNodes);

    // 监听视口变化事件
    this.network.on('zoom', this.throttle(this.updateViewport.bind(this), 100));
    this.network.on('dragEnd', this.throttle(this.updateViewport.bind(this), 100));

    // 初始渲染可见区域
    this.updateViewport();
  }

  /**
   * 创建空间索引
   */
  createSpatialIndex(nodes) {
    const index = new Map();
    const gridSize = 200; // 网格大小

    nodes.forEach(node => {
      const gridX = Math.floor((node.x || 0) / gridSize);
      const gridY = Math.floor((node.y || 0) / gridSize);
      const key = `${gridX},${gridY}`;

      if (!index.has(key)) {
        index.set(key, []);
      }
      index.get(key).push(node);
    });

    return index;
  }

  /**
   * 更新视口渲染
   */
  updateViewport() {
    if (this.isRendering) return;

    const viewport = this.network.getViewPosition();
    const scale = this.network.getScale();

    // 计算可见区域边界
    const bounds = this.calculateVisibleBounds(viewport, scale);

    // 获取可见节点和边
    const visibleNodes = this.getNodesInBounds(bounds);
    const visibleEdges = this.getEdgesForNodes(visibleNodes);

    // 批量更新渲染
    this.batchUpdateRender(visibleNodes, visibleEdges);
  }

  /**
   * 批量更新渲染
   */
  async batchUpdateRender(newNodes, newEdges) {
    this.isRendering = true;

    try {
      // 分块处理大量数据
      const nodeChunks = this.chunkArray(newNodes, this.options.chunkSize);
      const edgeChunks = this.chunkArray(newEdges, this.options.chunkSize);

      // 逐块渲染，避免阻塞UI
      for (let i = 0; i < Math.max(nodeChunks.length, edgeChunks.length); i++) {
        const nodes = nodeChunks[i] || [];
        const edges = edgeChunks[i] || [];

        if (nodes.length > 0 || edges.length > 0) {
          this.network.setData({ nodes, edges });

          // 让出控制权，保持UI响应
          await this.delay(this.options.renderDelay);
        }
      }
    } finally {
      this.isRendering = false;
    }
  }

  /**
   * 节流函数
   */
  throttle(func, limit) {
    let inThrottle;
    return function() {
      const args = arguments;
      const context = this;
      if (!inThrottle) {
        func.apply(context, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    }
  }

  /**
   * 延迟函数
   */
  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * 数组分块
   */
  chunkArray(array, chunkSize) {
    const chunks = [];
    for (let i = 0; i < array.length; i += chunkSize) {
      chunks.push(array.slice(i, i + chunkSize));
    }
    return chunks;
  }
}
```

##### 2. 多层缓存策略

```javascript
// 多层缓存管理器
class TopologyCacheManager {
  constructor() {
    // L1缓存：内存缓存（最快）
    this.memoryCache = new Map();

    // L2缓存：SessionStorage（中等）
    this.sessionCache = window.sessionStorage;

    // L3缓存：IndexedDB（持久化）
    this.indexedDBCache = null;

    this.initIndexedDB();
  }

  /**
   * 初始化IndexedDB
   */
  async initIndexedDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('TopologyCache', 1);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.indexedDBCache = request.result;
        resolve();
      };

      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains('topology')) {
          const store = db.createObjectStore('topology', { keyPath: 'key' });
          store.createIndex('timestamp', 'timestamp', { unique: false });
        }
      };
    });
  }

  /**
   * 获取缓存数据
   */
  async get(key) {
    // L1缓存查找
    if (this.memoryCache.has(key)) {
      const item = this.memoryCache.get(key);
      if (!this.isExpired(item)) {
        return item.data;
      }
      this.memoryCache.delete(key);
    }

    // L2缓存查找
    const sessionItem = this.sessionCache.getItem(key);
    if (sessionItem) {
      const parsed = JSON.parse(sessionItem);
      if (!this.isExpired(parsed)) {
        // 提升到L1缓存
        this.memoryCache.set(key, parsed);
        return parsed.data;
      }
      this.sessionCache.removeItem(key);
    }

    // L3缓存查找
    if (this.indexedDBCache) {
      const item = await this.getFromIndexedDB(key);
      if (item && !this.isExpired(item)) {
        // 提升到上层缓存
        this.memoryCache.set(key, item);
        this.sessionCache.setItem(key, JSON.stringify(item));
        return item.data;
      }
    }

    return null;
  }

  /**
   * 设置缓存数据
   */
  async set(key, data, ttl = 3600000) { // 默认1小时过期
    const item = {
      key,
      data,
      timestamp: Date.now(),
      ttl
    };

    // 设置到所有缓存层
    this.memoryCache.set(key, item);

    try {
      this.sessionCache.setItem(key, JSON.stringify(item));
    } catch (e) {
      // SessionStorage满了，清理旧数据
      this.cleanupSessionStorage();
    }

    if (this.indexedDBCache) {
      await this.setToIndexedDB(item);
    }
  }

  /**
   * 检查是否过期
   */
  isExpired(item) {
    return Date.now() - item.timestamp > item.ttl;
  }

  /**
   * 清理过期缓存
   */
  cleanup() {
    // 清理内存缓存
    for (const [key, item] of this.memoryCache.entries()) {
      if (this.isExpired(item)) {
        this.memoryCache.delete(key);
      }
    }

    // 清理SessionStorage
    this.cleanupSessionStorage();

    // 清理IndexedDB
    this.cleanupIndexedDB();
  }
}
```

##### 3. 组件懒加载和代码分割

```javascript
// 路由懒加载配置
const routes = [
  {
    path: '/topology/device',
    name: 'DeviceTopology',
    component: () => import(/* webpackChunkName: "device-topology" */ '@/views/DeviceTopology.vue'),
    meta: {
      title: '设备拓扑图',
      preload: true // 预加载标记
    }
  },
  {
    path: '/topology/port',
    name: 'PortTopology',
    component: () => import(/* webpackChunkName: "port-topology" */ '@/views/PortTopology.vue'),
    meta: {
      title: '端口拓扑图'
    }
  }
];

// 组件预加载器
class ComponentPreloader {
  constructor() {
    this.preloadedComponents = new Set();
    this.preloadQueue = [];
  }

  /**
   * 预加载组件
   */
  preload(componentImport) {
    if (this.preloadedComponents.has(componentImport)) {
      return Promise.resolve();
    }

    return componentImport().then(component => {
      this.preloadedComponents.add(componentImport);
      return component;
    });
  }

  /**
   * 批量预加载
   */
  batchPreload(components) {
    return Promise.all(
      components.map(component => this.preload(component))
    );
  }

  /**
   * 智能预加载（基于用户行为）
   */
  smartPreload(currentRoute) {
    // 根据当前路由预测可能访问的组件
    const predictions = this.predictNextComponents(currentRoute);

    // 在空闲时间预加载
    if ('requestIdleCallback' in window) {
      window.requestIdleCallback(() => {
        this.batchPreload(predictions);
      });
    } else {
      setTimeout(() => {
        this.batchPreload(predictions);
      }, 100);
    }
  }
}
```

##### 4. 性能监控和优化

```javascript
// 性能监控器
class PerformanceMonitor {
  constructor() {
    this.metrics = {
      renderTime: [],
      nodeCount: [],
      edgeCount: [],
      memoryUsage: [],
      interactionLatency: []
    };

    this.observers = [];
    this.setupObservers();
  }

  /**
   * 设置性能观察器
   */
  setupObservers() {
    // 长任务监控
    if ('PerformanceObserver' in window) {
      const longTaskObserver = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          if (entry.duration > 50) { // 超过50ms的任务
            console.warn('Long task detected:', entry);
            this.recordLongTask(entry);
          }
        }
      });

      longTaskObserver.observe({ entryTypes: ['longtask'] });
      this.observers.push(longTaskObserver);
    }

    // 内存使用监控
    if (performance.memory) {
      setInterval(() => {
        this.recordMemoryUsage();
      }, 5000); // 每5秒记录一次
    }
  }

  /**
   * 记录渲染性能
   */
  recordRenderPerformance(startTime, nodeCount, edgeCount) {
    const renderTime = performance.now() - startTime;

    this.metrics.renderTime.push({
      time: renderTime,
      timestamp: Date.now(),
      nodeCount,
      edgeCount
    });

    // 保持最近100条记录
    if (this.metrics.renderTime.length > 100) {
      this.metrics.renderTime = this.metrics.renderTime.slice(-100);
    }

    // 性能警告
    if (renderTime > 1000) { // 超过1秒
      console.warn(`Slow render detected: ${renderTime}ms for ${nodeCount} nodes`);
      this.suggestOptimizations(nodeCount, edgeCount, renderTime);
    }
  }

  /**
   * 优化建议
   */
  suggestOptimizations(nodeCount, edgeCount, renderTime) {
    const suggestions = [];

    if (nodeCount > 1000) {
      suggestions.push('启用虚拟化渲染');
    }

    if (edgeCount > 2000) {
      suggestions.push('考虑边的聚合显示');
    }

    if (renderTime > 2000) {
      suggestions.push('使用Web Worker进行计算');
    }

    return suggestions;
  }

  /**
   * 获取性能报告
   */
  getPerformanceReport() {
    return {
      averageRenderTime: this.average(this.metrics.renderTime.map(m => m.time)),
      maxRenderTime: Math.max(...this.metrics.renderTime.map(m => m.time)),
      averageNodeCount: this.average(this.metrics.renderTime.map(m => m.nodeCount)),
      memoryTrend: this.calculateMemoryTrend(),
      recommendations: this.generateRecommendations()
    };
  }
}
```

#### 5.4.2 后端性能优化

1. **数据库优化**
   
   - 索引优化
   - 查询优化
   - 连接池管理

2. **缓存策略**
   
   - Redis缓存热点数据
   - 查询结果缓存
   - 计算结果缓存

3. **异步处理**
   
   - 复杂计算异步化
   - 消息队列处理
   - 批量操作优化

## 6. 开发实施计划

### 6.1 项目阶段划分

#### 第一阶段：基础架构搭建（4周）

**目标**：建立统一的技术架构和基础功能

**主要任务**：

1. 统一数据模型设计和实现
2. 基础API接口开发
3. 前端项目架构搭建
4. 基础UI组件开发
5. 开发环境配置

**可交付成果**：

- 统一数据模型文档
- 基础API接口（CRUD操作）
- 前端项目脚手架
- 基础UI组件库
- 开发环境部署文档

**验收标准**：

- 数据模型通过评审
- API接口通过单元测试
- 前端项目可正常启动
- UI组件通过视觉测试

#### 第二阶段：设备级拓扑图开发（6周）

**目标**：实现设备级拓扑图的核心功能

**主要任务**：

1. 设备级拓扑图API开发
2. 拓扑构建算法实现
3. 路径分析功能开发
4. 故障影响分析功能
5. 前端可视化组件开发
6. 用户交互功能实现

**可交付成果**：

- 设备级拓扑图API
- 核心算法实现
- 可视化展示组件
- 交互功能模块
- 功能测试报告

**验收标准**：

- API接口功能完整
- 算法性能达标
- 可视化效果符合设计
- 交互体验流畅

#### 第三阶段：端口级拓扑图开发（6周）

**目标**：实现端口级拓扑图的详细功能

**主要任务**：

1. 端口级拓扑图API开发
2. 端口管理功能实现
3. 连接关系管理
4. 搜索和筛选功能
5. 批量操作功能
6. 数据导出功能

**可交付成果**：

- 端口级拓扑图API
- 端口管理模块
- 搜索筛选组件
- 批量操作工具
- 数据导出功能

**验收标准**：

- 端口管理功能完整
- 搜索性能达标
- 批量操作稳定
- 导出数据准确

#### 第四阶段：系统集成和优化（4周）

**目标**：整合两个模块，优化系统性能

**主要任务**：

1. 模块间集成测试
2. 性能优化和调优
3. 用户体验优化
4. 安全性加固
5. 文档完善

**可交付成果**：

- 集成测试报告
- 性能优化报告
- 安全测试报告
- 用户使用手册
- 部署运维文档

**验收标准**：

- 集成测试通过
- 性能指标达标
- 安全测试通过
- 文档完整准确

### 6.2 资源配置

#### 6.2.1 人员配置

- **项目经理**: 1人，负责项目管理和协调
- **架构师**: 1人，负责技术架构设计
- **后端开发**: 2人，负责API和算法开发
- **前端开发**: 2人，负责UI和交互开发
- **测试工程师**: 1人，负责功能和性能测试
- **UI设计师**: 1人，负责界面设计

#### 6.2.2 技术资源

- **开发环境**: 开发服务器、数据库服务器
- **测试环境**: 测试服务器、性能测试工具
- **生产环境**: 生产服务器、监控系统
- **开发工具**: IDE、版本控制、项目管理工具

### 6.3 风险控制

#### 6.3.1 技术风险

**风险**: 算法性能不达标
**影响**: 大数据量时响应缓慢
**缓解措施**: 

- 提前进行性能测试
- 准备算法优化方案
- 考虑分布式计算

**风险**: 前端渲染性能问题
**影响**: 用户体验差
**缓解措施**:

- 使用虚拟化技术
- 实现渐进式加载
- 优化渲染算法

#### 6.3.2 项目风险

**风险**: 需求变更频繁
**影响**: 开发进度延迟
**缓解措施**:

- 需求冻结机制
- 变更影响评估
- 敏捷开发方法

**风险**: 人员流失
**影响**: 项目延期
**缓解措施**:

- 知识文档化
- 代码规范化
- 备用人员计划

## 7. 测试方案

### 7.1 测试策略

#### 7.1.1 测试层次

1. **单元测试**: 覆盖率≥80%
2. **集成测试**: API接口测试
3. **系统测试**: 端到端功能测试
4. **性能测试**: 负载和压力测试
5. **安全测试**: 安全漏洞扫描
6. **兼容性测试**: 浏览器兼容性

#### 7.1.2 测试环境

- **开发测试**: 开发人员本地测试
- **集成测试**: 专用测试环境
- **系统测试**: 模拟生产环境
- **用户验收**: 用户测试环境

### 7.2 功能测试用例

#### 7.2.1 设备级拓扑图测试

**测试用例TC001**: 设备拓扑图加载

- **前置条件**: 系统中存在设备和连接数据
- **测试步骤**: 
  1. 访问设备级拓扑图页面
  2. 等待数据加载完成
  3. 验证设备节点显示
  4. 验证连接线显示
- **预期结果**: 拓扑图正确显示所有设备和连接

**测试用例TC002**: 路径分析功能

- **前置条件**: 拓扑图已加载
- **测试步骤**:
  1. 选择源设备和目标设备
  2. 执行路径分析
  3. 查看分析结果
- **预期结果**: 正确显示设备间的路径信息

#### 7.2.2 端口级拓扑图测试

**测试用例TC003**: 端口连接显示

- **前置条件**: 系统中存在端口连接数据
- **测试步骤**:
  1. 访问端口级拓扑图页面
  2. 选择要查看的设备
  3. 验证端口显示
  4. 验证连接关系
- **预期结果**: 正确显示设备端口和连接关系

**测试用例TC004**: 端口搜索功能

- **前置条件**: 端口级拓扑图已加载
- **测试步骤**:
  1. 在搜索框输入端口名称
  2. 执行搜索
  3. 验证搜索结果
- **预期结果**: 正确显示匹配的端口信息

### 7.3 性能测试方案

#### 7.3.1 性能指标

- **响应时间**: API响应时间<2秒
- **页面加载**: 首屏加载时间<3秒
- **并发用户**: 支持100个并发用户
- **数据量**: 支持10000个设备节点
- **内存使用**: 前端内存使用<500MB

#### 7.3.2 测试场景

**场景1**: 大数据量加载测试

- 测试数据: 10000个设备，50000个连接
- 测试指标: 加载时间、渲染性能
- 预期结果: 10秒内完成加载和渲染

**场景2**: 并发用户测试

- 测试条件: 100个并发用户同时访问
- 测试指标: 响应时间、系统稳定性
- 预期结果: 响应时间不超过5秒

**场景3**: 复杂路径分析测试

- 测试条件: 深度为10层的路径分析
- 测试指标: 计算时间、结果准确性
- 预期结果: 30秒内完成分析

### 7.4 兼容性测试

#### 7.4.1 浏览器兼容性

| 浏览器     | 版本  | 支持状态 |
| ------- | --- | ---- |
| Chrome  | 90+ | 完全支持 |
| Firefox | 88+ | 完全支持 |
| Safari  | 14+ | 完全支持 |
| Edge    | 90+ | 完全支持 |
| IE      | 11  | 基础支持 |

#### 7.4.2 设备兼容性

- **桌面端**: Windows、macOS、Linux
- **移动端**: iOS、Android（基础功能）
- **分辨率**: 1024x768 - 4K

## 8. 部署和维护

### 8.1 部署架构

#### 8.1.1 生产环境架构

```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   负载均衡   │    │   Web服务器  │    │  应用服务器  │
│   (Nginx)   │────│   (Nginx)   │────│  (Django)   │
└─────────────┘    └─────────────┘    └─────────────┘
                                              │
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   缓存服务   │    │   数据库     │    │   搜索引擎   │
│   (Redis)   │    │(PostgreSQL) │    │(Elasticsearch)│
└─────────────┘    └─────────────┘    └─────────────┘
```

#### 8.1.2 容器化部署

**Docker Compose配置**:

```yaml
version: '3.8'
services:
  web:
    build: ./frontend
    ports:
      - "80:80"
    depends_on:
      - api

  api:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/topology
      - REDIS_URL=redis://redis:6379/0
    depends_on:
      - db
      - redis

  db:
    image: postgres:13
    environment:
      - POSTGRES_DB=topology
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:6
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
```

### 8.2 监控和日志

#### 8.2.1 监控指标

**系统监控**:

- CPU使用率
- 内存使用率
- 磁盘使用率
- 网络流量

**应用监控**:

- API响应时间
- 错误率
- 并发用户数
- 数据库连接数

**业务监控**:

- 拓扑图加载次数
- 路径分析请求数
- 用户活跃度
- 功能使用统计

#### 8.2.2 日志管理

**日志分类**:

- 访问日志: 记录用户访问信息
- 应用日志: 记录应用运行状态
- 错误日志: 记录系统错误信息
- 审计日志: 记录重要操作

**日志格式**:

```json
{
  "timestamp": "2025-01-16T10:30:00Z",
  "level": "INFO",
  "service": "topology-api",
  "message": "Path analysis completed",
  "user_id": "user_123",
  "request_id": "req_456",
  "duration": 1.5,
  "metadata": {
    "source_device": "device_001",
    "target_device": "device_002"
  }
}
```

### 8.3 备份和恢复

#### 8.3.1 数据备份策略

**数据库备份**:

- 全量备份: 每日凌晨执行
- 增量备份: 每小时执行
- 备份保留: 30天
- 异地备份: 每周同步到异地

**文件备份**:

- 配置文件备份
- 日志文件归档
- 静态资源备份

#### 8.3.2 灾难恢复

**恢复等级**:

- RTO (恢复时间目标): 4小时
- RPO (恢复点目标): 1小时

**恢复流程**:

1. 故障确认和影响评估
2. 启动应急响应流程
3. 数据恢复和系统重建
4. 服务验证和切换
5. 故障总结和改进

### 8.4 安全措施

#### 8.4.1 访问控制

- **身份认证**: JWT Token认证
- **权限控制**: RBAC角色权限模型
- **API安全**: 接口访问频率限制
- **数据加密**: 敏感数据加密存储

#### 8.4.2 安全防护

- **防火墙**: 网络访问控制
- **SSL/TLS**: 数据传输加密
- **SQL注入防护**: 参数化查询
- **XSS防护**: 输入输出过滤
- **CSRF防护**: Token验证

## 9. 总结

### 9.1 文档整合成果

本统一拓扑图系统设计方案成功整合了原有的两个设计文档，解决了以下关键问题：

1. **数据模型统一**: 建立了统一的设备、端口、连接数据模型，消除了字段定义冲突
2. **API接口规范**: 设计了层次化的API架构，避免了接口命名冲突
3. **UI设计统一**: 制定了统一的视觉设计语言和交互标准
4. **技术架构整合**: 建立了支持两种视图的统一技术架构
5. **功能互补**: 将设备级和端口级功能有机结合，形成完整的解决方案

### 9.2 核心优势

1. **完整性**: 覆盖了从设备级到端口级的完整拓扑管理需求
2. **一致性**: 统一的数据模型、API接口和用户体验
3. **可扩展性**: 模块化设计支持功能扩展和技术升级
4. **高性能**: 优化的算法和架构支持大规模数据处理
5. **易维护**: 清晰的架构设计和完善的文档支持

### 9.3 实施建议

1. **分阶段实施**: 按照制定的4个阶段逐步推进，确保每个阶段的质量
2. **持续集成**: 建立CI/CD流程，确保代码质量和部署效率
3. **用户参与**: 在开发过程中持续收集用户反馈，及时调整设计
4. **性能监控**: 建立完善的监控体系，及时发现和解决性能问题
5. **文档维护**: 保持文档与代码同步更新，确保可维护性

### 9.4 预期效果

通过实施本统一拓扑图系统设计方案，预期达到以下效果：

1. **用户体验提升**: 统一的界面设计和交互标准提供一致的用户体验
2. **管理效率提高**: 设备级和端口级的双重视图满足不同层次的管理需求
3. **故障处理能力增强**: 智能路径分析和故障影响评估提高故障处理效率
4. **系统可维护性提升**: 统一的技术架构和规范降低维护成本
5. **扩展能力增强**: 模块化设计支持未来功能扩展和技术升级

### 9.5 成功关键因素

1. **团队协作**: 前后端开发团队的紧密协作
2. **技术选型**: 合适的技术栈选择和架构设计
3. **质量控制**: 严格的代码审查和测试流程
4. **用户反馈**: 及时收集和响应用户需求
5. **持续优化**: 基于监控数据的持续性能优化

---

**文档版本**: v1.0  
**创建日期**: 2025-08-27
**最后更新**: 2025-08-27
**文档状态**: 设计完成，待开发实施  
**负责人**: 拓扑图开发团队  
**审核状态**: 待审核