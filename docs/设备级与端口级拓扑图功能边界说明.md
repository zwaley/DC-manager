# 设备级与端口级拓扑图功能边界说明

## 概述

本文档基于《统一拓扑图系统设计方案.md》，详细说明设备级拓扑图和端口级拓扑图的功能边界、适用场景和实现方案，为开发团队提供清晰的实施指导。

## 功能边界定义

### 设备级拓扑图

#### 核心功能
- **设备关系可视化**：以设备为节点，显示设备间的供电连接关系
- **层级结构展示**：体现供电系统的层级关系（变压器→配电柜→UPS→负载设备）

#### 适用场景
1. **宏观供电架构分析**：了解整体供电系统结构
2. **容量规划**：分析供电系统的负载分布和容量利用率

#### 显示内容
- 设备名称、类型
- 设备间的供电连接关系
- 连接类型（直连、通过空开、通过熔丝等）
- 额定功率和当前负载
- 设备重要性等级

### 端口级拓扑图

#### 核心功能
- **端口连接详情**：显示设备端口间的精确连接关系
- **容量利用分析**：显示端口容量和当前负载情况

#### 适用场景
1. **精细化连接管理**：管理设备端口的具体连接情况
2. **容量优化配置**：优化端口资源配置，提高利用率
3. **扩容规划**：分析端口资源使用情况，规划扩容需求

#### 显示内容
- 端口名称、类型
- 端口容量和当前负载
- 端口间的物理连接
- 电缆信息（类型、规格）

## 数据模型对比

### 设备级拓扑数据结构

```json
{
  "nodes": [
    {
      "id": "device_1",
      "type": "device",
      "name": "主配电柜A",
      "device_type": "distribution_cabinet",
      "capacity": 1000,
      "current_load": 750,
      "is_critical": true,
      "position": { "x": 100, "y": 200 },
      "style": {
        "color": "#4CAF50",
        "size": 60,
        "icon": "/static/icons/distribution_cabinet.svg"
      }
    }
  ],
  "edges": [
    {
      "id": "conn_1",
      "source": "device_1",
      "target": "device_2",
      "connection_type": "交流",
      "rated_current": 100,
      "style": {
        "color": "#FFD700",
        "width": 3
      }
    }
  ]
}
```

### 端口级拓扑数据结构

```json
{
  "nodes": [
    {
      "id": "port_1",
      "type": "port",
      "device_id": "device_1",
      "port_name": "OUT-01",
      "port_type": "output",
      "capacity": 100,
      "current_load": 75,
      "position": { "x": 120, "y": 180 },
      "style": {
        "color": "#FF9800",
        "shape": "rectangle"
      }
    }
  ],
  "edges": [
    {
      "id": "port_conn_1",
      "source": "port_1",
      "target": "port_2",
      "cable_info": {
        "type": "copper",
        "specification": "4mm²"
      },
      "connection_quality": "good",
      "style": {
        "color": "#9C27B0",
        "width": 2
      }
    }
  ]
}
```

## 视图切换机制

### 切换逻辑

1. **默认视图**：系统启动时显示设备级拓扑图
2. **双击设备**：双击设备节点时，切换到该设备的端口级视图
3. **面包屑导航**：提供视图层级导航，支持快速返回上级视图
4. **视图标签**：提供设备级/端口级视图切换标签

### 数据加载策略

```javascript
class TopologyViewManager {
  constructor() {
    this.currentView = 'device'; // 'device' | 'port'
    this.currentDeviceId = null;
    this.viewHistory = [];
  }
  
  // 切换到设备级视图
  async switchToDeviceView(filters = {}) {
    this.currentView = 'device';
    this.currentDeviceId = null;
    
    const data = await this.loadDeviceTopology(filters);
    this.renderTopology(data);
    this.updateBreadcrumb(['设备级拓扑']);
  }
  
  // 切换到端口级视图
  async switchToPortView(deviceId, deviceName) {
    this.currentView = 'port';
    this.currentDeviceId = deviceId;
    
    const data = await this.loadPortTopology(deviceId);
    this.renderTopology(data);
    this.updateBreadcrumb(['设备级拓扑', `${deviceName} - 端口视图`]);
  }
  
  // 加载设备级拓扑数据
  async loadDeviceTopology(filters) {
    const response = await fetch('/api/topology/devices', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ filters })
    });
    return await response.json();
  }
  
  // 加载端口级拓扑数据
  async loadPortTopology(deviceId) {
    const response = await fetch(`/api/topology/ports?device_id=${deviceId}`);
    return await response.json();
  }
}
```

## 交互功能差异

### 设备级拓扑交互

| 操作 | 功能描述 | 实现方式 |
|------|----------|----------|
| 单击设备 | 显示设备详情面板 | 侧边栏展示设备信息 |
| 双击设备 | 切换到端口级视图 | 加载该设备的端口拓扑 |
| 悬停设备 | 显示基本信息提示 | Tooltip显示设备信息 |
| 右键设备 | 显示操作菜单 | 编辑、删除、查看详情等 |
| 拖拽设备 | 调整设备位置 | 实时更新坐标并保存 |

### 端口级拓扑交互

| 操作 | 功能描述 | 实现方式 |
|------|----------|----------|
| 单击端口 | 显示端口详情面板 | 侧边栏展示端口信息 |
| 双击端口 | 高亮连接路径 | 突出显示相关连接 |
| 悬停端口 | 显示端口信息 | Tooltip显示容量和负载 |
| 右键端口 | 显示端口操作菜单 | 查看详情、编辑等 |
| 连线操作 | 创建端口连接 | 拖拽创建新连接 |

## 性能优化策略

### 数据加载优化

1. **按需加载**：只加载当前视图所需的数据
2. **缓存机制**：缓存已加载的拓扑数据，避免重复请求
3. **增量更新**：只更新变化的节点和连接
4. **分页加载**：大型拓扑图支持分页或区域加载

### 渲染性能优化

1. **视图裁剪**：只渲染可视区域内的元素
2. **LOD技术**：根据缩放级别调整显示细节
3. **批量操作**：批量更新DOM，减少重绘次数
4. **WebGL加速**：大规模数据使用WebGL渲染

## API接口规范

### 设备级拓扑API

```python
@app.get("/api/topology/devices")
async def get_device_topology(
    filters: Optional[dict] = None,
    include_inactive: bool = False
) -> DeviceTopologyResponse:
    """
    获取设备级拓扑数据
    
    Args:
        filters: 筛选条件（设备类型等）
    
    Returns:
        设备级拓扑图数据
    """
```

### 端口级拓扑API

```python
@app.get("/api/topology/ports")
async def get_port_topology(
    device_id: Optional[int] = None,
    device_ids: Optional[List[int]] = None
) -> PortTopologyResponse:
    """
    获取端口级拓扑数据
    
    Args:
        device_id: 单个设备ID
        device_ids: 多个设备ID列表
    
    Returns:
        端口级拓扑图数据
    """
```

## 实施建议

### 开发优先级

1. **第一阶段**：实现设备级拓扑图的基础功能
2. **第二阶段**：开发端口级拓扑图和视图切换
3. **第三阶段**：完善交互功能和性能优化

### 测试策略

1. **单元测试**：测试数据模型和API接口
2. **集成测试**：测试视图切换和数据同步
3. **性能测试**：测试大规模数据的渲染性能
4. **用户测试**：验证用户体验和操作流程

### 风险控制

1. **数据一致性**：确保设备级和端口级数据的同步
2. **性能瓶颈**：监控大规模拓扑图的渲染性能
3. **用户体验**：避免视图切换时的操作混乱
4. **兼容性**：确保不同浏览器的兼容性

## 总结

设备级拓扑图和端口级拓扑图各有其特定的应用场景和功能边界：

- **设备级拓扑图**：适用于宏观的供电架构分析和容量规划
- **端口级拓扑图**：适用于精细化的连接管理和容量优化

通过统一的数据模型和灵活的视图切换机制，可以为用户提供从宏观到微观的完整拓扑可视化体验，满足不同层次的管理需求。

在实施过程中，应优先实现设备级拓扑图的核心功能，然后逐步扩展到端口级拓扑图，确保系统的稳定性和可用性。